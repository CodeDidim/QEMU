/*
 * QEMU model of the CRF APB control registers for clock controller.
 *
 * Copyright (c) 2017 Xilinx Inc.
 *
 * Autogenerated by xregqemu.py 2017-02-09.
 * Written-by: Alistair Francis <alistair.francis@xilinx.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "qemu/osdep.h"
#include "hw/sysbus.h"
#include "hw/register-dep.h"
#include "qemu/bitops.h"
#include "qemu/log.h"

#include "hw/fdt_generic_util.h"

#ifndef XILINX_CRF_ERR_DEBUG
#define XILINX_CRF_ERR_DEBUG 0
#endif

#define TYPE_XILINX_CRF "xlnx,zynq3-crf"

#define XILINX_CRF(obj) \
     OBJECT_CHECK(XlnxZynq3Crf, (obj), TYPE_XILINX_CRF)

DEP_REG32(ERR_CTRL, 0x0)
    DEP_FIELD(ERR_CTRL, SLVERR_ENABLE, 1, 0)
DEP_REG32(IR_STATUS, 0x4)
    DEP_FIELD(IR_STATUS, ADDR_DECODE_ERR, 1, 0)
DEP_REG32(IR_MASK, 0x8)
    DEP_FIELD(IR_MASK, ADDR_DECODE_ERR, 1, 0)
DEP_REG32(IR_ENABLE, 0xc)
    DEP_FIELD(IR_ENABLE, ADDR_DECODE_ERR, 1, 0)
DEP_REG32(IR_DISABLE, 0x10)
    DEP_FIELD(IR_DISABLE, ADDR_DECODE_ERR, 1, 0)
DEP_REG32(ECO, 0x18)
DEP_REG32(WPROT, 0x1c)
    DEP_FIELD(WPROT, ACTIVE, 1, 0)
DEP_REG32(APLL_CTRL, 0x40)
    DEP_FIELD(APLL_CTRL, POST_SRC, 3, 24)
    DEP_FIELD(APLL_CTRL, PRE_SRC, 3, 20)
    DEP_FIELD(APLL_CTRL, CLKOUTDIV, 2, 16)
    DEP_FIELD(APLL_CTRL, FBDIV, 8, 8)
    DEP_FIELD(APLL_CTRL, BYPASS, 1, 3)
    DEP_FIELD(APLL_CTRL, RESET, 1, 0)
DEP_REG32(APLL_CFG, 0x44)
    DEP_FIELD(APLL_CFG, LOCK_DLY, 7, 25)
    DEP_FIELD(APLL_CFG, LOCK_CNT, 10, 13)
    DEP_FIELD(APLL_CFG, LFHF, 2, 10)
    DEP_FIELD(APLL_CFG, CP, 4, 5)
    DEP_FIELD(APLL_CFG, RES, 4, 0)
DEP_REG32(APLL_FRAC_CFG, 0x48)
    DEP_FIELD(APLL_FRAC_CFG, ENABLED, 1, 31)
    DEP_FIELD(APLL_FRAC_CFG, SEED, 3, 22)
    DEP_FIELD(APLL_FRAC_CFG, ALGRTHM, 1, 19)
    DEP_FIELD(APLL_FRAC_CFG, ORDER, 1, 18)
    DEP_FIELD(APLL_FRAC_CFG, DATA, 16, 0)
DEP_REG32(PLL_STATUS, 0x50)
    DEP_FIELD(PLL_STATUS, APLL_STABLE, 1, 2)
    DEP_FIELD(PLL_STATUS, APLL_LOCK, 1, 0)
DEP_REG32(PLL_REG0, 0x5c)
    DEP_FIELD(PLL_REG0, FREQ_COMP, 2, 22)
    DEP_FIELD(PLL_REG0, LOCK_SAT_HIGH, 10, 12)
    DEP_FIELD(PLL_REG0, UNLOCK_CNT, 10, 2)
    DEP_FIELD(PLL_REG0, SYNTH_CLK_DIV, 2, 0)
DEP_REG32(PLL_REG1, 0x60)
    DEP_FIELD(PLL_REG1, EN_VCO_DIV1, 1, 29)
    DEP_FIELD(PLL_REG1, EN_VCO_DIV6, 1, 28)
    DEP_FIELD(PLL_REG1, EN_SYNC_CK_TEST, 1, 27)
    DEP_FIELD(PLL_REG1, EN_TESTIN, 1, 26)
    DEP_FIELD(PLL_REG1, VCO_STARTUP_HYST_DISABLE, 1, 25)
    DEP_FIELD(PLL_REG1, VCO_STARTUP_ALT_EN, 1, 24)
    DEP_FIELD(PLL_REG1, VCO_STARTUP_ADJ, 1, 23)
    DEP_FIELD(PLL_REG1, VCO_KICK_DISABLE, 1, 22)
    DEP_FIELD(PLL_REG1, VCO_GATE_CCI_B, 1, 21)
    DEP_FIELD(PLL_REG1, VCO_HIGH_RANGE_EN, 1, 20)
    DEP_FIELD(PLL_REG1, PFD_STARTUP, 1, 19)
    DEP_FIELD(PLL_REG1, PFD, 7, 12)
    DEP_FIELD(PLL_REG1, SEL_SLIPD, 1, 11)
    DEP_FIELD(PLL_REG1, SENSE_TEST_EN, 1, 10)
    DEP_FIELD(PLL_REG1, SPARE_ANALOG, 5, 5)
    DEP_FIELD(PLL_REG1, SPARE_DIGITAL, 5, 0)
DEP_REG32(PLL_REG2, 0x64)
    DEP_FIELD(PLL_REG2, SUP_SEL_VCCINT, 1, 28)
    DEP_FIELD(PLL_REG2, SUP_SEL_VCCAUX, 1, 27)
    DEP_FIELD(PLL_REG2, SUP_SEL_VBG, 1, 26)
    DEP_FIELD(PLL_REG2, SUP_SEL_AREG, 1, 25)
    DEP_FIELD(PLL_REG2, SUP_SEL_MVDD, 1, 24)
    DEP_FIELD(PLL_REG2, VLF_HIGH_REF_SEL, 1, 20)
    DEP_FIELD(PLL_REG2, VLF_HIGH_SEL, 2, 18)
    DEP_FIELD(PLL_REG2, VLF_VALID_SEL, 3, 15)
    DEP_FIELD(PLL_REG2, VLF_VALID_PWDN, 1, 14)
    DEP_FIELD(PLL_REG2, VLF_HIGH_PWDN_B, 1, 13)
    DEP_FIELD(PLL_REG2, LF_LOW_SEL, 1, 12)
    DEP_FIELD(PLL_REG2, LF_NEN, 2, 10)
    DEP_FIELD(PLL_REG2, LF_PEN, 2, 8)
    DEP_FIELD(PLL_REG2, VLF_HIGH_DIS_B, 1, 7)
    DEP_FIELD(PLL_REG2, MAN_LF, 3, 4)
    DEP_FIELD(PLL_REG2, ANALOG_MISC, 4, 0)
DEP_REG32(PLL_REG3, 0x68)
    DEP_FIELD(PLL_REG3, TESTOUT1_MUX_SEL, 6, 26)
    DEP_FIELD(PLL_REG3, TESTOUT0_MUX_SEL, 6, 20)
    DEP_FIELD(PLL_REG3, CP_BIAS_TRIP_SET, 1, 19)
    DEP_FIELD(PLL_REG3, CP_RES, 2, 17)
    DEP_FIELD(PLL_REG3, HVLF_CNT_TEST_EN, 1, 16)
    DEP_FIELD(PLL_REG3, HVLF_CNT_TEST, 6, 10)
    DEP_FIELD(PLL_REG3, AVDD_COMP_SET, 3, 7)
    DEP_FIELD(PLL_REG3, AVDD_VBG_PD, 3, 4)
    DEP_FIELD(PLL_REG3, AVDD_VBG_SEL, 4, 0)
DEP_REG32(PLL_REG4, 0x6c)
    DEP_FIELD(PLL_REG4, FRACT_TEST_CK_SEL, 1, 21)
    DEP_FIELD(PLL_REG4, FRACT_TEST_EN, 1, 20)
    DEP_FIELD(PLL_REG4, TEST_PLL_CK_SEL, 3, 17)
    DEP_FIELD(PLL_REG4, FRACT_TEST_SEL, 3, 14)
    DEP_FIELD(PLL_REG4, FBCLK_PREDIV2, 1, 13)
    DEP_FIELD(PLL_REG4, VCO_BYPASS, 1, 12)
    DEP_FIELD(PLL_REG4, TESTOUT3_MUX_SEL, 6, 6)
    DEP_FIELD(PLL_REG4, TESTOUT2_MUX_SEL, 6, 0)
DEP_REG32(PLL_REG5, 0x70)
    DEP_FIELD(PLL_REG5, CONTROL_1, 16, 16)
    DEP_FIELD(PLL_REG5, CONTROL_0, 16, 0)
DEP_REG32(PLL_REG6, 0x74)
    DEP_FIELD(PLL_REG6, CONTROL_3, 16, 16)
    DEP_FIELD(PLL_REG6, CONTROL_2, 16, 0)
DEP_REG32(PLL_REG7, 0x78)
    DEP_FIELD(PLL_REG7, CONTROL_5, 16, 16)
    DEP_FIELD(PLL_REG7, CONTROL_4, 16, 0)
DEP_REG32(PLL_REG8, 0x7c)
    DEP_FIELD(PLL_REG8, CONTROL_7, 16, 16)
    DEP_FIELD(PLL_REG8, CONTROL_6, 16, 0)
DEP_REG32(APLL_TO_XPD_CTRL, 0x100)
    DEP_FIELD(APLL_TO_XPD_CTRL, CLKACT, 1, 25)
    DEP_FIELD(APLL_TO_XPD_CTRL, DIVISOR0, 10, 8)
DEP_REG32(FPD_TOP_SWITCH_CTRL, 0x104)
    DEP_FIELD(FPD_TOP_SWITCH_CTRL, CLKACT, 1, 25)
    DEP_FIELD(FPD_TOP_SWITCH_CTRL, DIVISOR0, 10, 8)
    DEP_FIELD(FPD_TOP_SWITCH_CTRL, SRCSEL, 3, 0)
DEP_REG32(FPD_LSBUS_CTRL, 0x108)
    DEP_FIELD(FPD_LSBUS_CTRL, CLKACT, 1, 25)
    DEP_FIELD(FPD_LSBUS_CTRL, DIVISOR0, 10, 8)
    DEP_FIELD(FPD_LSBUS_CTRL, SRCSEL, 3, 0)
DEP_REG32(ACPU_CTRL, 0x10c)
    DEP_FIELD(ACPU_CTRL, CLKACT, 1, 25)
    DEP_FIELD(ACPU_CTRL, DIVISOR0, 10, 8)
    DEP_FIELD(ACPU_CTRL, SRCSEL, 3, 0)
DEP_REG32(DBG_TRACE_CTRL, 0x110)
    DEP_FIELD(DBG_TRACE_CTRL, CLKACT, 1, 25)
    DEP_FIELD(DBG_TRACE_CTRL, DIVISOR0, 10, 8)
    DEP_FIELD(DBG_TRACE_CTRL, SRCSEL, 3, 0)
DEP_REG32(DBG_FPD_CTRL, 0x114)
    DEP_FIELD(DBG_FPD_CTRL, CLKACT, 1, 25)
    DEP_FIELD(DBG_FPD_CTRL, DIVISOR0, 10, 8)
    DEP_FIELD(DBG_FPD_CTRL, SRCSEL, 3, 0)
DEP_REG32(DBG_TSTMP_CTRL, 0x118)
    DEP_FIELD(DBG_TSTMP_CTRL, CLKACT, 1, 24)
    DEP_FIELD(DBG_TSTMP_CTRL, DIVISOR0, 10, 8)
    DEP_FIELD(DBG_TSTMP_CTRL, SRCSEL, 3, 0)
DEP_REG32(SAFETY_CHK, 0x150)
DEP_REG32(RST_APU, 0x300)
    DEP_FIELD(RST_APU, ACPU3_PWRON, 1, 11)
    DEP_FIELD(RST_APU, ACPU2_PWRON, 1, 10)
    DEP_FIELD(RST_APU, ACPU1_PWRON, 1, 9)
    DEP_FIELD(RST_APU, ACPU0_PWRON, 1, 8)
    DEP_FIELD(RST_APU, ACPU_GIC_RESET, 1, 6)
    DEP_FIELD(RST_APU, ACPU_L2_RESET, 1, 5)
    DEP_FIELD(RST_APU, ACPU3, 1, 3)
    DEP_FIELD(RST_APU, ACPU2, 1, 2)
    DEP_FIELD(RST_APU, ACPU1, 1, 1)
    DEP_FIELD(RST_APU, ACPU0, 1, 0)
DEP_REG32(RST_DBG_TRACE, 0x308)
    DEP_FIELD(RST_DBG_TRACE, RESET, 1, 0)
DEP_REG32(RST_DBG_FPD, 0x30c)
    DEP_FIELD(RST_DBG_FPD, RESET, 1, 0)
DEP_REG32(RST_DBG_TSTMP, 0x310)
    DEP_FIELD(RST_DBG_TSTMP, RESET, 1, 0)

#define R_MAX (R_RST_DBG_TSTMP + 1)

typedef struct XlnxZynq3Crf {
    SysBusDevice parent_obj;
    MemoryRegion iomem;
    qemu_irq irq_ir;

    uint32_t regs[R_MAX];
    DepRegisterInfo regs_info[R_MAX];
} XlnxZynq3Crf;

static void ir_update_irq(XlnxZynq3Crf *s)
{
    bool pending = s->regs[R_IR_STATUS] & ~s->regs[R_IR_MASK];
    qemu_set_irq(s->irq_ir, pending);
}

static void ir_status_postw(DepRegisterInfo *reg, uint64_t val64)
{
    XlnxZynq3Crf *s = XILINX_CRF(reg->opaque);
    ir_update_irq(s);
}

static uint64_t ir_enable_prew(DepRegisterInfo *reg, uint64_t val64)
{
    XlnxZynq3Crf *s = XILINX_CRF(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IR_MASK] &= ~val;
    ir_update_irq(s);
    return 0;
}

static uint64_t ir_disable_prew(DepRegisterInfo *reg, uint64_t val64)
{
    XlnxZynq3Crf *s = XILINX_CRF(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IR_MASK] |= val;
    ir_update_irq(s);
    return 0;
}

static DepRegisterAccessInfo crf_regs_info[] = {
    {   .name = "ERR_CTRL",  .decode.addr = A_ERR_CTRL,
    },{ .name = "IR_STATUS",  .decode.addr = A_IR_STATUS,
        .w1c = 0x1,
        .post_write = ir_status_postw,
    },{ .name = "IR_MASK",  .decode.addr = A_IR_MASK,
        .reset = 0x1,
        .ro = 0x1,
    },{ .name = "IR_ENABLE",  .decode.addr = A_IR_ENABLE,
        .pre_write = ir_enable_prew,
    },{ .name = "IR_DISABLE",  .decode.addr = A_IR_DISABLE,
        .pre_write = ir_disable_prew,
    },{ .name = "ECO",  .decode.addr = A_ECO,
    },{ .name = "WPROT",  .decode.addr = A_WPROT,
    },{ .name = "APLL_CTRL",  .decode.addr = A_APLL_CTRL,
        .reset = 0x14809,
        .rsvd = 0xf88c00f6,
    },{ .name = "APLL_CFG",  .decode.addr = A_APLL_CFG,
        .rsvd = 0x1801210,
    },{ .name = "APLL_FRAC_CFG",  .decode.addr = A_APLL_FRAC_CFG,
        .rsvd = 0x7e330000,
    },{ .name = "PLL_STATUS",  .decode.addr = A_PLL_STATUS,
        .reset = 0x4,
        .rsvd = 0xfa,
        .ro = 0x5,
    },{ .name = "PLL_REG0",  .decode.addr = A_PLL_REG0,
        .reset = 0x7e9007,
        .rsvd = 0xff000000,
    },{ .name = "PLL_REG1",  .decode.addr = A_PLL_REG1,
        .reset = 0x4021000,
        .rsvd = 0xc0000000,
    },{ .name = "PLL_REG2",  .decode.addr = A_PLL_REG2,
        .reset = 0x9a880,
        .rsvd = 0xe0e00000,
        .ro = 0xe00000,
    },{ .name = "PLL_REG3",  .decode.addr = A_PLL_REG3,
        .reset = 0x201e8,
    },{ .name = "PLL_REG4",  .decode.addr = A_PLL_REG4,
        .rsvd = 0xffc00000,
    },{ .name = "PLL_REG5",  .decode.addr = A_PLL_REG5,
        .reset = 0x7d4df37c,
    },{ .name = "PLL_REG6",  .decode.addr = A_PLL_REG6,
        .reset = 0xebc85042,
    },{ .name = "PLL_REG7",  .decode.addr = A_PLL_REG7,
        .reset = 0xadfbd4df,
    },{ .name = "PLL_REG8",  .decode.addr = A_PLL_REG8,
        .reset = 0x4c2eb2c7,
    },{ .name = "APLL_TO_XPD_CTRL",  .decode.addr = A_APLL_TO_XPD_CTRL,
        .reset = 0x400,
        .rsvd = 0xfdfc00ff,
    },{ .name = "FPD_TOP_SWITCH_CTRL",  .decode.addr = A_FPD_TOP_SWITCH_CTRL,
        .reset = 0x2002500,
        .rsvd = 0xfdfc00f8,
    },{ .name = "FPD_LSBUS_CTRL",  .decode.addr = A_FPD_LSBUS_CTRL,
        .reset = 0x2002500,
        .rsvd = 0xfdfc00f8,
    },{ .name = "ACPU_CTRL",  .decode.addr = A_ACPU_CTRL,
        .reset = 0x2500,
        .rsvd = 0xfdfc00f8,
    },{ .name = "DBG_TRACE_CTRL",  .decode.addr = A_DBG_TRACE_CTRL,
        .reset = 0x2000,
        .rsvd = 0xfdfc00f8,
    },{ .name = "DBG_FPD_CTRL",  .decode.addr = A_DBG_FPD_CTRL,
        .reset = 0x2000,
        .rsvd = 0xfdfc00f8,
    },{ .name = "DBG_TSTMP_CTRL",  .decode.addr = A_DBG_TSTMP_CTRL,
        .reset = 0x800,
        .rsvd = 0xfefc00f8,
    },{ .name = "SAFETY_CHK",  .decode.addr = A_SAFETY_CHK,
    },{ .name = "RST_APU",  .decode.addr = A_RST_APU,
        .reset = 0xf2f,
        .rsvd = 0xf090,
        .gpios = (DepRegisterGPIOMapping[]) {
            { .name = "RST_APU_GPIO", .bit_pos = 0, .num = 4 },
            { },
        },
        .inhibit_reset = 1u << 31,
    },{ .name = "RST_DBG_TRACE",  .decode.addr = A_RST_DBG_TRACE,
        .reset = 0x1,
    },{ .name = "RST_DBG_FPD",  .decode.addr = A_RST_DBG_FPD,
        .reset = 0x1,
    },{ .name = "RST_DBG_TSTMP",  .decode.addr = A_RST_DBG_TSTMP,
        .reset = 0x1,
    }
};

static void crf_reset(DeviceState *dev)
{
    XlnxZynq3Crf *s = XILINX_CRF(dev);
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(s->regs_info); ++i) {
        dep_register_reset(&s->regs_info[i]);
    }

    s->regs[R_PLL_STATUS] |= R_PLL_STATUS_APLL_LOCK_MASK;
    ir_update_irq(s);
}

static uint64_t crf_read(void *opaque, hwaddr addr, unsigned size)
{
    XlnxZynq3Crf *s = XILINX_CRF(opaque);
    DepRegisterInfo *r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: read from %" HWADDR_PRIx "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr);
        return 0;
    }
    return dep_register_read(r);
}

static void crf_write(void *opaque, hwaddr addr, uint64_t value,
                      unsigned size)
{
    XlnxZynq3Crf *s = XILINX_CRF(opaque);
    DepRegisterInfo *r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: write to %" HWADDR_PRIx "=%" PRIx64 "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr, value);
        return;
    }
    dep_register_write(r, value, ~0);
}

static const MemoryRegionOps crf_ops = {
    .read = crf_read,
    .write = crf_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static void crf_realize(DeviceState *dev, Error **errp)
{
    XlnxZynq3Crf *s = XILINX_CRF(dev);
    const char *prefix = object_get_canonical_path(OBJECT(dev));
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(crf_regs_info); ++i) {
        DepRegisterInfo *r;

        r = &s->regs_info[crf_regs_info[i].decode.addr / 4];
        *r = (DepRegisterInfo) {
            .data = (uint8_t *)&s->regs[
                    crf_regs_info[i].decode.addr / 4],
            .data_size = sizeof(uint32_t),
            .access = &crf_regs_info[i],
            .debug = XILINX_CRF_ERR_DEBUG,
            .prefix = prefix,
            .opaque = s,
        };

        dep_register_init(r);
        qdev_pass_all_gpios(DEVICE(r), dev);
    }
}

static void crf_init(Object *obj)
{
    XlnxZynq3Crf *s = XILINX_CRF(obj);
    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);

    memory_region_init_io(&s->iomem, obj, &crf_ops, s,
                          TYPE_XILINX_CRF, R_MAX * 4);
    sysbus_init_mmio(sbd, &s->iomem);
    sysbus_init_irq(sbd, &s->irq_ir);
}

static const VMStateDescription vmstate_crf = {
    .name = TYPE_XILINX_CRF,
    .version_id = 1,
    .minimum_version_id = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32_ARRAY(regs, XlnxZynq3Crf, R_MAX),
        VMSTATE_END_OF_LIST(),
    }
};

static const FDTGenericGPIOSet crf_gpios[] = {
    {
        .names = &fdt_generic_gpio_name_set_gpio,
        .gpios = (FDTGenericGPIOConnection[]) {
            { .name = "RST_APU_GPIO",   .fdt_index = 0,   .range = 4 },
            { },
        }
    },
    { },
};

static void crf_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    FDTGenericGPIOClass *fggc = FDT_GENERIC_GPIO_CLASS(klass);

    dc->reset = crf_reset;
    dc->realize = crf_realize;
    dc->vmsd = &vmstate_crf;
    fggc->controller_gpios = crf_gpios;
}

static const TypeInfo crf_info = {
    .name          = TYPE_XILINX_CRF,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(XlnxZynq3Crf),
    .class_init    = crf_class_init,
    .instance_init = crf_init,
    .interfaces    = (InterfaceInfo[]) {
        { TYPE_FDT_GENERIC_GPIO },
        { }
    },
};

static void crf_register_types(void)
{
    type_register_static(&crf_info);
}

type_init(crf_register_types)
