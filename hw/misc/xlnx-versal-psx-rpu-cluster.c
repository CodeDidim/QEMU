/*
 * QEMU model of the PSX_RPU_CLUSTER Realtime Processing Unit
 *
 * Copyright (c) 2021 Xilinx Inc.
 *
 * Autogenerated by xregqemu.py 2021-03-31.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "qemu/osdep.h"
#include "hw/sysbus.h"
#include "hw/register.h"
#include "qemu/bitops.h"
#include "qemu/log.h"
#include "migration/vmstate.h"
#include "hw/irq.h"
#include "qapi/error.h"
#include "hw/fdt_generic_util.h"
#include "cpu.h"
#include "hw/qdev-properties.h"

#ifndef XILINX_PSX_RPU_CLUSTER_ERR_DEBUG
#define XILINX_PSX_RPU_CLUSTER_ERR_DEBUG 0
#endif

#define TYPE_XILINX_PSX_RPU_CLUSTER "xlnx.psx_rpu_cluster"

#define XILINX_PSX_RPU_CLUSTER(obj) \
     OBJECT_CHECK(PSX_RPU_CLUSTER, (obj), TYPE_XILINX_PSX_RPU_CLUSTER)

REG32(CORE_0_CFG0, 0x0)
    FIELD(CORE_0_CFG0, REMAP_AXIM_ADDR, 5, 1)
    FIELD(CORE_0_CFG0, TCMBOOT, 4, 1)
    FIELD(CORE_0_CFG0, CPUHALT, 0, 1)
REG32(CORE_0_CFG1, 0x4)
    FIELD(CORE_0_CFG1, THUMBEXCEPTIONS, 8, 1)
    FIELD(CORE_0_CFG1, ENDIANESS, 4, 1)
    FIELD(CORE_0_CFG1, L1CACHEINVDIS, 0, 1)
REG32(CORE_0_VECTABLE, 0x10)
    FIELD(CORE_0_VECTABLE, BASE_HI, 8, 24)
    FIELD(CORE_0_VECTABLE, BASE_LO, 5, 3)
REG32(CORE_0_PRIMERRIDX, 0x40)
    FIELD(CORE_0_PRIMERRIDX, IDX, 0, 25)
REG32(CORE_0_PRIMERRMEM, 0x44)
    FIELD(CORE_0_PRIMERRMEM, MEM, 0, 15)
REG32(CORE_0_PRIMERRV, 0x48)
    FIELD(CORE_0_PRIMERRV, VLD, 0, 1)
REG32(CORE_0_SECMERRIDX, 0x50)
    FIELD(CORE_0_SECMERRIDX, IDX, 0, 25)
REG32(CORE_0_SECMERRMEM, 0x54)
    FIELD(CORE_0_SECMERRMEM, MEM, 0, 15)
REG32(CORE_0_SECMERRV, 0x58)
    FIELD(CORE_0_SECMERRV, VLD, 0, 1)
REG32(CORE_0_STATUS, 0x70)
REG32(CORE_0_PWRDWN, 0x80)
    FIELD(CORE_0_PWRDWN, EN, 0, 1)
REG32(CORE_0_PREQ, 0x90)
    FIELD(CORE_0_PREQ, PREQ, 0, 1)
REG32(CORE_0_PSTATE, 0x94)
    FIELD(CORE_0_PSTATE, PSTATE, 0, 1)
REG32(CORE_0_PACTIVE, 0x98)
    FIELD(CORE_0_PACTIVE, PDENY, 9, 1)
    FIELD(CORE_0_PACTIVE, PACCEPT, 8, 1)
    FIELD(CORE_0_PACTIVE, PACTIVE, 0, 2)
REG32(CORE_0_ISR, 0xf0)
    FIELD(CORE_0_ISR, PACTIVE1, 0, 1)
REG32(CORE_0_IMR, 0xf4)
    FIELD(CORE_0_IMR, PACTIVE1, 0, 1)
REG32(CORE_0_IEN, 0xf8)
    FIELD(CORE_0_IEN, PACTIVE1, 0, 1)
REG32(CORE_0_IDS, 0xfc)
    FIELD(CORE_0_IDS, PACTIVE1, 0, 1)
REG32(CORE_1_CFG0, 0x100)
    FIELD(CORE_1_CFG0, REMAP_AXIM_ADDR, 5, 1)
    FIELD(CORE_1_CFG0, TCMBOOT, 4, 1)
    FIELD(CORE_1_CFG0, CPUHALT, 0, 1)
REG32(CORE_1_CFG1, 0x104)
    FIELD(CORE_1_CFG1, THUMBEXCEPTIONS, 8, 1)
    FIELD(CORE_1_CFG1, ENDIANESS, 4, 1)
    FIELD(CORE_1_CFG1, L1CACHEINVDIS, 0, 1)
REG32(CORE_1_VECTABLE, 0x110)
    FIELD(CORE_1_VECTABLE, BASE_HI, 8, 24)
    FIELD(CORE_1_VECTABLE, BASE_LO, 5, 3)
REG32(CORE_1_PRIMERRIDX, 0x140)
    FIELD(CORE_1_PRIMERRIDX, IDX, 0, 25)
REG32(CORE_1_PRIMERRMEM, 0x144)
    FIELD(CORE_1_PRIMERRMEM, MEM, 0, 15)
REG32(CORE_1_PRIMERRV, 0x148)
    FIELD(CORE_1_PRIMERRV, VLD, 0, 1)
REG32(CORE_1_SECMERRIDX, 0x150)
    FIELD(CORE_1_SECMERRIDX, IDX, 0, 25)
REG32(CORE_1_SECMERRMEM, 0x154)
    FIELD(CORE_1_SECMERRMEM, MEM, 0, 15)
REG32(CORE_1_SECMERRV, 0x158)
    FIELD(CORE_1_SECMERRV, VLD, 0, 1)
REG32(CORE_1_STATUS, 0x170)
REG32(CORE_1_PWRDWN, 0x180)
    FIELD(CORE_1_PWRDWN, EN, 0, 1)
REG32(CORE_1_PREQ, 0x190)
    FIELD(CORE_1_PREQ, PREQ, 0, 1)
REG32(CORE_1_PSTATE, 0x194)
    FIELD(CORE_1_PSTATE, PSTATE, 0, 1)
REG32(CORE_1_PACTIVE, 0x198)
    FIELD(CORE_1_PACTIVE, PDENY, 9, 1)
    FIELD(CORE_1_PACTIVE, PACCEPT, 8, 1)
    FIELD(CORE_1_PACTIVE, PACTIVE, 0, 2)
REG32(CORE_1_IDS, 0x19c)
    FIELD(CORE_1_IDS, PACTIVE1, 0, 1)
REG32(CORE_1_ISR, 0x1f0)
    FIELD(CORE_1_ISR, PACTIVE1, 0, 1)
REG32(CORE_1_IMR, 0x1f4)
    FIELD(CORE_1_IMR, PACTIVE1, 0, 1)
REG32(CORE_1_IEN, 0x1f8)
    FIELD(CORE_1_IEN, PACTIVE1, 0, 1)
REG32(CLUSTER_CFG, 0x800)
    FIELD(CLUSTER_CFG, RAMPROTEN, 12, 1)
    FIELD(CLUSTER_CFG, CLUSTERUTID_BIT1, 9, 1)
    FIELD(CLUSTER_CFG, CLUSTERUTID_BIT0, 8, 1)
    FIELD(CLUSTER_CFG, SLSPLIT, 0, 1)
REG32(CLUSTER_AXIS, 0x810)
    FIELD(CLUSTER_AXIS, TCM_BASE, 24, 8)
REG32(CLUSTER_PERIPH, 0x814)
    FIELD(CLUSTER_PERIPH, BASE, 21, 11)
REG32(CLUSTER_LLPP, 0x81c)
    FIELD(CLUSTER_LLPP, BASE, 12, 20)
    FIELD(CLUSTER_LLPP, SIZE, 0, 4)
REG32(CLUSTER_DCLSCOMPIN_LO, 0x840)
    FIELD(CLUSTER_DCLSCOMPIN_LO, COMPIN, 0, 28)
REG32(CLUSTER_DCLSCOMPIN_HI, 0x848)
    FIELD(CLUSTER_DCLSCOMPIN_HI, COMPIN, 4, 6)
REG32(CLUSTER_DCLSCOMPOUT_LO, 0x850)
    FIELD(CLUSTER_DCLSCOMPOUT_LO, COMPOUT, 0, 28)
REG32(CLUSTER_DCLSCOMPOUT_HI, 0x858)
    FIELD(CLUSTER_DCLSCOMPOUT_HI, COMPOUT, 4, 6)
REG32(CLUSTER_INTR_0, 0x860)
REG32(CLUSTER_INTR_1, 0x864)
REG32(CLUSTER_INTR_2, 0x868)
REG32(CLUSTER_INTR_3, 0x86c)
REG32(CLUSTER_INTR_4, 0x870)
REG32(CLUSTER_INTR_MASK_0, 0x880)
REG32(CLUSTER_INTR_MASK_1, 0x884)
REG32(CLUSTER_INTR_MASK_2, 0x888)
REG32(CLUSTER_INTR_MASK_3, 0x88c)
REG32(CLUSTER_INTR_MASK_4, 0x890)
REG32(CLUSTER_CCF_VAL, 0x8a0)
    FIELD(CLUSTER_CCF_VAL, TEST_MBIST_MODE, 7, 1)
    FIELD(CLUSTER_CCF_VAL, TEST_SCAN_MODE_LP, 6, 1)
    FIELD(CLUSTER_CCF_VAL, TEST_SCAN_MODE, 5, 1)
    FIELD(CLUSTER_CCF_VAL, ISO, 4, 1)
    FIELD(CLUSTER_CCF_VAL, PGE, 3, 1)
    FIELD(CLUSTER_CCF_VAL, R50_DBG_RST, 2, 1)
    FIELD(CLUSTER_CCF_VAL, R50_RST, 1, 1)
    FIELD(CLUSTER_CCF_VAL, PGE_RST, 0, 1)
REG32(CLUSTER_CCF_MASK, 0x8a4)
    FIELD(CLUSTER_CCF_MASK, TEST_MBIST_MODE, 7, 1)
    FIELD(CLUSTER_CCF_MASK, TEST_SCAN_MODE_LP, 6, 1)
    FIELD(CLUSTER_CCF_MASK, TEST_SCAN_MODE, 5, 1)
    FIELD(CLUSTER_CCF_MASK, ISO, 4, 1)
    FIELD(CLUSTER_CCF_MASK, PGE, 3, 1)
    FIELD(CLUSTER_CCF_MASK, R50_DBG_RST, 2, 1)
    FIELD(CLUSTER_CCF_MASK, R50_RST, 1, 1)
    FIELD(CLUSTER_CCF_MASK, PGE_RST, 0, 1)
REG32(CLUSTER_SAFETY_CHK, 0x8b0)
REG32(CLUSTER_MPID, 0x8f0)
    FIELD(CLUSTER_MPID, AFF2_MSB, 17, 7)
    FIELD(CLUSTER_MPID, AFF2_BIT0, 16, 1)
    FIELD(CLUSTER_MPID, AFF1_MSB, 9, 7)
    FIELD(CLUSTER_MPID, AFF1_BIT0, 8, 1)
REG32(RPU_ISR, 0x1000)
    FIELD(RPU_ISR, APB_ERR, 0, 1)
REG32(RPU_IMR, 0x1004)
    FIELD(RPU_IMR, APB_ERR, 0, 1)
REG32(RPU_IEN, 0x1008)
    FIELD(RPU_IEN, APB_ERR, 0, 1)
REG32(RPU_IDS, 0x100c)
    FIELD(RPU_IDS, APB_ERR, 0, 1)
REG32(RPU_PCIL_ERR, 0x1100)
    FIELD(RPU_PCIL_ERR, CORE_1, 1, 1)
    FIELD(RPU_PCIL_ERR, CORE_0, 0, 1)

#define PSX_RPU_CLUSTER_R_MAX (R_RPU_PCIL_ERR + 1)

#define CORE_COUNT 2

typedef struct PSX_RPU_CLUSTER {
    SysBusDevice parent_obj;
    MemoryRegion iomem;
    qemu_irq irq_core_0_imr;
    qemu_irq irq_rpu_imr;
    qemu_irq irq_core_1_imr;

    bool rpu_rst[CORE_COUNT];
    qemu_irq halt[CORE_COUNT];
    qemu_irq thumb[CORE_COUNT];

    uint32_t axis_base;
    MemoryRegion *tcm_mr;
    ARMCPU *cpus[CORE_COUNT];
    uint32_t regs[PSX_RPU_CLUSTER_R_MAX];
    RegisterInfo regs_info[PSX_RPU_CLUSTER_R_MAX];
} PSX_RPU_CLUSTER;

static void core_0_imr_update_irq(PSX_RPU_CLUSTER *s)
{
    bool pending = s->regs[R_CORE_0_ISR] & ~s->regs[R_CORE_0_IMR];
    qemu_set_irq(s->irq_core_0_imr, pending);
}

static void core_0_isr_postw(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    core_0_imr_update_irq(s);
}

static uint64_t core_0_ien_prew(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    uint32_t val = val64;

    s->regs[R_CORE_0_IMR] &= ~val;
    core_0_imr_update_irq(s);
    return 0;
}

static uint64_t core_0_ids_prew(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    uint32_t val = val64;

    s->regs[R_CORE_0_IMR] |= val;
    core_0_imr_update_irq(s);
    return 0;
}

static void rpu_imr_update_irq(PSX_RPU_CLUSTER *s)
{
    bool pending = s->regs[R_RPU_ISR] & ~s->regs[R_RPU_IMR];
    qemu_set_irq(s->irq_rpu_imr, pending);
}

static void rpu_isr_postw(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    rpu_imr_update_irq(s);
}

static uint64_t rpu_ien_prew(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    uint32_t val = val64;

    s->regs[R_RPU_IMR] &= ~val;
    rpu_imr_update_irq(s);
    return 0;
}

static uint64_t rpu_ids_prew(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    uint32_t val = val64;

    s->regs[R_RPU_IMR] |= val;
    rpu_imr_update_irq(s);
    return 0;
}

static void core_1_imr_update_irq(PSX_RPU_CLUSTER *s)
{
    bool pending = s->regs[R_CORE_1_ISR] & ~s->regs[R_CORE_1_IMR];
    qemu_set_irq(s->irq_core_1_imr, pending);
}

static void core_1_isr_postw(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    core_1_imr_update_irq(s);
}

static uint64_t core_1_ien_prew(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    uint32_t val = val64;

    s->regs[R_CORE_1_IMR] &= ~val;
    core_1_imr_update_irq(s);
    return 0;
}

static uint64_t core_1_ids_prew(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    uint32_t val = val64;

    s->regs[R_CORE_1_IMR] |= val;
    core_1_imr_update_irq(s);
    return 0;
}

static void rpu_update_gpios(PSX_RPU_CLUSTER *s)
{
    int i;
    bool ncpuhalt[CORE_COUNT];
    bool use_thumb[CORE_COUNT];
    bool slsplit = ARRAY_FIELD_EX32(s->regs, CLUSTER_CFG, SLSPLIT);

    ncpuhalt[0] = ARRAY_FIELD_EX32(s->regs, CORE_0_CFG0, CPUHALT);
    ncpuhalt[1] = ARRAY_FIELD_EX32(s->regs, CORE_1_CFG0, CPUHALT);

    /*
     * CFG1 properties
     */
    use_thumb[0] = ARRAY_FIELD_EX32(s->regs, CORE_0_CFG1, THUMBEXCEPTIONS);
    use_thumb[1] = ARRAY_FIELD_EX32(s->regs, CORE_1_CFG1, THUMBEXCEPTIONS);

    for (i = 0; i < CORE_COUNT; i++) {
        if (!slsplit && (i != 0)) {
            ncpuhalt[i] = true;
        }
        qemu_set_irq(s->halt[i],
                     s->rpu_rst[i] | ncpuhalt[i]);
        qemu_set_irq(s->thumb[i], use_thumb[i]);
    }
}

static void core_cfg_postw(RegisterInfo *reg, uint64_t val)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);

    rpu_update_gpios(s);
}

static void vectable_base_postw(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    int cpu_num;

    switch (reg->access->addr) {
    case A_CORE_0_VECTABLE:
        cpu_num = 0;
        break;
    case A_CORE_1_VECTABLE:
        cpu_num = 1;
        break;
    default:
        g_assert_not_reached();
    };

    if (s->cpus[cpu_num]) {
        object_property_set_int(OBJECT(s->cpus[cpu_num]), "rvbar",
                                val64, &error_abort);
    }
}

static void cluster_axis_postw(RegisterInfo *reg, uint64_t val64)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(reg->opaque);
    uint32_t val = val64;
    uint32_t addr;
    MemoryRegionSection section;

    if (!s->tcm_mr) {
        return;
    }

    section = memory_region_find(s->tcm_mr, 0, 0x400000);
    addr = section.offset_within_address_space;
    addr &= 0xFFFFFF;
    addr |= val & R_CLUSTER_AXIS_TCM_BASE_MASK;
    memory_region_set_address(s->tcm_mr, addr);
    memory_region_unref(section.mr);
}

static const RegisterAccessInfo psx_rpu_cluster_regs_info[] = {
    {   .name = "CORE_0_CFG0",  .addr = A_CORE_0_CFG0,
        .reset = 0x10,
        .rsvd = 0xffffffce,
        .post_write = core_cfg_postw,
    },{ .name = "CORE_0_CFG1",  .addr = A_CORE_0_CFG1,
        .rsvd = 0xfffffeee,
        .post_write = core_cfg_postw,
    },{ .name = "CORE_0_VECTABLE",  .addr = A_CORE_0_VECTABLE,
        .rsvd = 0x1f,
        .post_write = vectable_base_postw,
    },{ .name = "CORE_0_PRIMERRIDX",  .addr = A_CORE_0_PRIMERRIDX,
        .rsvd = 0xfe000000,
        .ro = 0x1ffffff,
    },{ .name = "CORE_0_PRIMERRMEM",  .addr = A_CORE_0_PRIMERRMEM,
        .rsvd = 0xffff8000,
        .ro = 0x7fff,
    },{ .name = "CORE_0_PRIMERRV",  .addr = A_CORE_0_PRIMERRV,
        .rsvd = 0xfffffffe,
        .ro = 0x1,
    },{ .name = "CORE_0_SECMERRIDX",  .addr = A_CORE_0_SECMERRIDX,
        .rsvd = 0xfe000000,
        .ro = 0x1ffffff,
    },{ .name = "CORE_0_SECMERRMEM",  .addr = A_CORE_0_SECMERRMEM,
        .rsvd = 0xffff8000,
        .ro = 0x7fff,
    },{ .name = "CORE_0_SECMERRV",  .addr = A_CORE_0_SECMERRV,
        .rsvd = 0xfffffffe,
        .ro = 0x1,
    },{ .name = "CORE_0_STATUS",  .addr = A_CORE_0_STATUS,
        .rsvd = 0xffffffff,
    },{ .name = "CORE_0_PWRDWN",  .addr = A_CORE_0_PWRDWN,
        .rsvd = 0xfffffffe,
    },{ .name = "CORE_0_PREQ",  .addr = A_CORE_0_PREQ,
        .rsvd = 0xfffffffe,
    },{ .name = "CORE_0_PSTATE",  .addr = A_CORE_0_PSTATE,
        .rsvd = 0xfffffffe,
    },{ .name = "CORE_0_PACTIVE",  .addr = A_CORE_0_PACTIVE,
        .rsvd = 0xfffffcfc,
        .ro = 0x303,
    },{ .name = "CORE_0_ISR",  .addr = A_CORE_0_ISR,
        .rsvd = 0xfffffffe,
        .w1c = 0x1,
        .post_write = core_0_isr_postw,
    },{ .name = "CORE_0_IMR",  .addr = A_CORE_0_IMR,
        .reset = 0x1,
        .rsvd = 0xfffffffe,
        .ro = 0x1,
    },{ .name = "CORE_0_IEN",  .addr = A_CORE_0_IEN,
        .rsvd = 0xfffffffe,
        .pre_write = core_0_ien_prew,
    },{ .name = "CORE_0_IDS",  .addr = A_CORE_0_IDS,
        .rsvd = 0xfffffffe,
        .pre_write = core_0_ids_prew,
    },{ .name = "CORE_1_CFG0",  .addr = A_CORE_1_CFG0,
        .reset = 0x10,
        .rsvd = 0xffffffce,
        .post_write = core_cfg_postw,
    },{ .name = "CORE_1_CFG1",  .addr = A_CORE_1_CFG1,
        .rsvd = 0xfffffeee,
        .post_write = core_cfg_postw,
    },{ .name = "CORE_1_VECTABLE",  .addr = A_CORE_1_VECTABLE,
        .rsvd = 0x1f,
        .post_write = vectable_base_postw,
    },{ .name = "CORE_1_PRIMERRIDX",  .addr = A_CORE_1_PRIMERRIDX,
        .rsvd = 0xfe000000,
        .ro = 0x1ffffff,
    },{ .name = "CORE_1_PRIMERRMEM",  .addr = A_CORE_1_PRIMERRMEM,
        .rsvd = 0xffff8000,
        .ro = 0x7fff,
    },{ .name = "CORE_1_PRIMERRV",  .addr = A_CORE_1_PRIMERRV,
        .rsvd = 0xfffffffe,
        .ro = 0x1,
    },{ .name = "CORE_1_SECMERRIDX",  .addr = A_CORE_1_SECMERRIDX,
        .rsvd = 0xfe000000,
        .ro = 0x1ffffff,
    },{ .name = "CORE_1_SECMERRMEM",  .addr = A_CORE_1_SECMERRMEM,
        .rsvd = 0xffff8000,
        .ro = 0x7fff,
    },{ .name = "CORE_1_SECMERRV",  .addr = A_CORE_1_SECMERRV,
        .rsvd = 0xfffffffe,
        .ro = 0x1,
    },{ .name = "CORE_1_STATUS",  .addr = A_CORE_1_STATUS,
        .rsvd = 0xffffffff,
    },{ .name = "CORE_1_PWRDWN",  .addr = A_CORE_1_PWRDWN,
        .rsvd = 0xfffffffe,
    },{ .name = "CORE_1_PREQ",  .addr = A_CORE_1_PREQ,
        .rsvd = 0xfffffffe,
    },{ .name = "CORE_1_PSTATE",  .addr = A_CORE_1_PSTATE,
        .rsvd = 0xfffffffe,
    },{ .name = "CORE_1_PACTIVE",  .addr = A_CORE_1_PACTIVE,
        .rsvd = 0xfffffcfc,
        .ro = 0x303,
    },{ .name = "CORE_1_IDS",  .addr = A_CORE_1_IDS,
        .rsvd = 0xfffffffe,
        .pre_write = core_1_ids_prew,
    },{ .name = "CORE_1_ISR",  .addr = A_CORE_1_ISR,
        .rsvd = 0xfffffffe,
        .w1c = 0x1,
        .post_write = core_1_isr_postw,
    },{ .name = "CORE_1_IMR",  .addr = A_CORE_1_IMR,
        .reset = 0x1,
        .rsvd = 0xfffffffe,
        .ro = 0x1,
    },{ .name = "CORE_1_IEN",  .addr = A_CORE_1_IEN,
        .rsvd = 0xfffffffe,
        .pre_write = core_1_ien_prew,
    },{ .name = "CLUSTER_CFG",  .addr = A_CLUSTER_CFG,
        .rsvd = 0xffffecfe,
        .ro = 0x100,
    },{ .name = "CLUSTER_AXIS",  .addr = A_CLUSTER_AXIS,
        .rsvd = 0xffffff,
        .post_write = cluster_axis_postw,
    },{ .name = "CLUSTER_PERIPH",  .addr = A_CLUSTER_PERIPH,
        .reset = 0xf9000000,
        .rsvd = 0xfff,
    },{ .name = "CLUSTER_LLPP",  .addr = A_CLUSTER_LLPP,
        .rsvd = 0xff0,
    },{ .name = "CLUSTER_DCLSCOMPIN_LO",  .addr = A_CLUSTER_DCLSCOMPIN_LO,
        .rsvd = 0xf0000000,
    },{ .name = "CLUSTER_DCLSCOMPIN_HI",  .addr = A_CLUSTER_DCLSCOMPIN_HI,
        .rsvd = 0xfffffc0f,
    },{ .name = "CLUSTER_DCLSCOMPOUT_LO",  .addr = A_CLUSTER_DCLSCOMPOUT_LO,
        .rsvd = 0xf0000000,
        .ro = 0xfffffff,
    },{ .name = "CLUSTER_DCLSCOMPOUT_HI",  .addr = A_CLUSTER_DCLSCOMPOUT_HI,
        .rsvd = 0xfffffc0f,
        .ro = 0x3f0,
    },{ .name = "CLUSTER_INTR_0",  .addr = A_CLUSTER_INTR_0,
    },{ .name = "CLUSTER_INTR_1",  .addr = A_CLUSTER_INTR_1,
    },{ .name = "CLUSTER_INTR_2",  .addr = A_CLUSTER_INTR_2,
    },{ .name = "CLUSTER_INTR_3",  .addr = A_CLUSTER_INTR_3,
    },{ .name = "CLUSTER_INTR_4",  .addr = A_CLUSTER_INTR_4,
    },{ .name = "CLUSTER_INTR_MASK_0",  .addr = A_CLUSTER_INTR_MASK_0,
    },{ .name = "CLUSTER_INTR_MASK_1",  .addr = A_CLUSTER_INTR_MASK_1,
    },{ .name = "CLUSTER_INTR_MASK_2",  .addr = A_CLUSTER_INTR_MASK_2,
    },{ .name = "CLUSTER_INTR_MASK_3",  .addr = A_CLUSTER_INTR_MASK_3,
    },{ .name = "CLUSTER_INTR_MASK_4",  .addr = A_CLUSTER_INTR_MASK_4,
    },{ .name = "CLUSTER_CCF_VAL",  .addr = A_CLUSTER_CCF_VAL,
        .reset = 0x7,
        .rsvd = 0xffffff00,
    },{ .name = "CLUSTER_CCF_MASK",  .addr = A_CLUSTER_CCF_MASK,
        .rsvd = 0xffffff00,
    },{ .name = "CLUSTER_SAFETY_CHK",  .addr = A_CLUSTER_SAFETY_CHK,
    },{ .name = "CLUSTER_MPID",  .addr = A_CLUSTER_MPID,
        .rsvd = 0xff0000ff,
        .ro = 0x10100,
    },{ .name = "RPU_ISR",  .addr = A_RPU_ISR,
        .rsvd = 0xfffffffe,
        .w1c = 0x1,
        .post_write = rpu_isr_postw,
    },{ .name = "RPU_IMR",  .addr = A_RPU_IMR,
        .reset = 0x1,
        .rsvd = 0xfffffffe,
        .ro = 0x1,
    },{ .name = "RPU_IEN",  .addr = A_RPU_IEN,
        .rsvd = 0xfffffffe,
        .pre_write = rpu_ien_prew,
    },{ .name = "RPU_IDS",  .addr = A_RPU_IDS,
        .rsvd = 0xfffffffe,
        .pre_write = rpu_ids_prew,
    },{ .name = "RPU_PCIL_ERR",  .addr = A_RPU_PCIL_ERR,
        .rsvd = 0xfffffffc,
        .w1c = 0x3,
    }
};

static void psx_rpu_cluster_reset_enter(Object *obj, ResetType type)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(obj);
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(s->regs_info); ++i) {
        switch (i) {
        case R_CLUSTER_AXIS:
            continue;
        default:
            register_reset(&s->regs_info[i]);
        };
    }
    s->regs[R_CLUSTER_AXIS] = s->axis_base &
                              R_CLUSTER_AXIS_TCM_BASE_MASK;
}

static void psx_rpu_cluster_reset_hold(Object *obj)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(obj);

    core_0_imr_update_irq(s);
    rpu_imr_update_irq(s);
    core_1_imr_update_irq(s);
}

static const MemoryRegionOps psx_rpu_cluster_ops = {
    .read = register_read_memory,
    .write = register_write_memory,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static void rpu_core_rst_handler(void *opaque, int irq, int level)
{
     PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(opaque);

     s->rpu_rst[irq] = level;
     rpu_update_gpios(s);
}

static void psx_rpu_cluster_realize(DeviceState *dev, Error **errp)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(dev);

    qdev_init_gpio_in_named(dev, rpu_core_rst_handler, "rst", CORE_COUNT);
    qdev_init_gpio_out_named(dev, s->halt, "halt", CORE_COUNT);
    qdev_init_gpio_out_named(dev, s->thumb, "thumb", CORE_COUNT);
}

static void psx_rpu_cluster_init(Object *obj)
{
    PSX_RPU_CLUSTER *s = XILINX_PSX_RPU_CLUSTER(obj);
    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
    RegisterInfoArray *reg_array;
    char *prop_name;
    int i;

    memory_region_init(&s->iomem, obj, TYPE_XILINX_PSX_RPU_CLUSTER,
                       PSX_RPU_CLUSTER_R_MAX * 4);
    reg_array =
        register_init_block32(DEVICE(obj), psx_rpu_cluster_regs_info,
                              ARRAY_SIZE(psx_rpu_cluster_regs_info),
                              s->regs_info, s->regs,
                              &psx_rpu_cluster_ops,
                              XILINX_PSX_RPU_CLUSTER_ERR_DEBUG,
                              PSX_RPU_CLUSTER_R_MAX * 4);
    memory_region_add_subregion(&s->iomem,
                                0x0,
                                &reg_array->mem);
    sysbus_init_mmio(sbd, &s->iomem);
    sysbus_init_irq(sbd, &s->irq_core_0_imr);
    sysbus_init_irq(sbd, &s->irq_rpu_imr);
    sysbus_init_irq(sbd, &s->irq_core_1_imr);

    for (i = 0; i < CORE_COUNT; ++i) {
        prop_name = g_strdup_printf("cpu%d", i);
        object_property_add_link(obj, prop_name, TYPE_ARM_CPU,
                             (Object **)&s->cpus[i],
                             qdev_prop_allow_set_link_before_realize,
                             OBJ_PROP_LINK_STRONG);
        g_free(prop_name);
    }

    prop_name = g_strdup_printf("tcm-mr");
    object_property_add_link(obj, prop_name, TYPE_MEMORY_REGION,
                             (Object **)&s->tcm_mr,
                             qdev_prop_allow_set_link_before_realize,
                             OBJ_PROP_LINK_STRONG);
    g_free(prop_name);
}

static const FDTGenericGPIOSet psx_rpu_cluster_cntrl_gpio[] = {
    {
      .names = &fdt_generic_gpio_name_set_gpio,
      .gpios = (FDTGenericGPIOConnection[]) {
        { .name = "halt", .fdt_index = 0, .range = 2},
        { .name = "thumb", .fdt_index = 2, .range = 2},
        { },
      },
    },
    { },
};

static const FDTGenericGPIOSet psx_rpu_cluster_client_gpio[] = {
    {
      .names = &fdt_generic_gpio_name_set_gpio,
      .gpios = (FDTGenericGPIOConnection[]) {
        { .name = "rst", .fdt_index = 0, .range = 2},
        { },
      },
    },
    { },
};

static const VMStateDescription vmstate_psx_rpu_cluster = {
    .name = TYPE_XILINX_PSX_RPU_CLUSTER,
    .version_id = 1,
    .minimum_version_id = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32_ARRAY(regs, PSX_RPU_CLUSTER, PSX_RPU_CLUSTER_R_MAX),
        VMSTATE_END_OF_LIST(),
    }
};

static Property psx_rpu_cluster_prop[] = {
    DEFINE_PROP_UINT32("axis-base", PSX_RPU_CLUSTER, axis_base,
                       0xFF000000),
    DEFINE_PROP_END_OF_LIST(),
};

static void psx_rpu_cluster_class_init(ObjectClass *klass, void *data)
{
    ResettableClass *rc = RESETTABLE_CLASS(klass);
    DeviceClass *dc = DEVICE_CLASS(klass);
    FDTGenericGPIOClass *fggc = FDT_GENERIC_GPIO_CLASS(klass);

    dc->realize = psx_rpu_cluster_realize;
    dc->vmsd = &vmstate_psx_rpu_cluster;
    rc->phases.enter = psx_rpu_cluster_reset_enter;
    rc->phases.hold = psx_rpu_cluster_reset_hold;
    fggc->controller_gpios = psx_rpu_cluster_cntrl_gpio;
    fggc->client_gpios = psx_rpu_cluster_client_gpio;
    device_class_set_props(dc, psx_rpu_cluster_prop);
}

static const TypeInfo psx_rpu_cluster_info = {
    .name          = TYPE_XILINX_PSX_RPU_CLUSTER,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(PSX_RPU_CLUSTER),
    .class_init    = psx_rpu_cluster_class_init,
    .instance_init = psx_rpu_cluster_init,
    .interfaces = (InterfaceInfo[]) {
        { TYPE_FDT_GENERIC_GPIO },
        { }
    },
};

static void psx_rpu_cluster_register_types(void)
{
    type_register_static(&psx_rpu_cluster_info);
}

type_init(psx_rpu_cluster_register_types)
