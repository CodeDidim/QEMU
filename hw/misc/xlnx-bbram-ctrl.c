/*
 * QEMU model of the BBRAM Battery Backed RAM
 *
 * Copyright (c) 2014-2020 Xilinx Inc.
 *
 * Autogenerated by xregqemu.py 2020-02-06.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "qemu/osdep.h"
#include "hw/sysbus.h"
#include "hw/register.h"
#include "qemu/error-report.h"
#include "qemu/bitops.h"
#include "qemu/log.h"
#include "qapi/error.h"
#include "sysemu/blockdev.h"
#include "sysemu/block-backend.h"
#include "migration/vmstate.h"
#include "hw/qdev-properties.h"

#include "hw/zynqmp_aes_key.h"
#include "hw/irq.h"

#ifndef XILINX_BBRAM_CTRL_ERR_DEBUG
#define XILINX_BBRAM_CTRL_ERR_DEBUG 0
#endif

#define TYPE_XILINX_BBRAM_CTRL "xlnx.bbram-ctrl"

#define XILINX_BBRAM_CTRL(obj) \
     OBJECT_CHECK(BBRAMCtrl, (obj), TYPE_XILINX_BBRAM_CTRL)

#define DB_PRINT_L(lvl, fmt, args...) do { \
    if (XILINX_BBRAM_CTRL_ERR_DEBUG >= lvl) { \
        qemu_log("%s: " fmt, __func__, ## args); \
    } \
} while (0);

#define DB_PRINT(fmt, args...) DB_PRINT_L(1, fmt, ## args)

REG32(BBRAM_STATUS, 0x0)
    FIELD(BBRAM_STATUS, AES_CRC_PASS, 9, 1)
    FIELD(BBRAM_STATUS, AES_CRC_DONE, 8, 1)
    FIELD(BBRAM_STATUS, BBRAM_ZEROIZED, 4, 1)
    FIELD(BBRAM_STATUS, PGM_MODE, 0, 1)
REG32(BBRAM_CTRL, 0x4)
    FIELD(BBRAM_CTRL, ZEROIZE, 0, 1)
REG32(PGM_MODE, 0x8)
REG32(BBRAM_AES_CRC, 0xc)
REG32(BBRAM_0, 0x10)
REG32(BBRAM_1, 0x14)
REG32(BBRAM_2, 0x18)
REG32(BBRAM_3, 0x1c)
REG32(BBRAM_4, 0x20)
REG32(BBRAM_5, 0x24)
REG32(BBRAM_6, 0x28)
REG32(BBRAM_7, 0x2c)
REG32(BBRAM_8, 0x30)
REG32(BBRAM_SLVERR, 0x34)
    FIELD(BBRAM_SLVERR, ENABLE, 0, 1)
REG32(BBRAM_ISR, 0x38)
    FIELD(BBRAM_ISR, APB_SLVERR, 0, 1)
REG32(BBRAM_IMR, 0x3c)
    FIELD(BBRAM_IMR, APB_SLVERR, 0, 1)
REG32(BBRAM_IER, 0x40)
    FIELD(BBRAM_IER, APB_SLVERR, 0, 1)
REG32(BBRAM_IDR, 0x44)
    FIELD(BBRAM_IDR, APB_SLVERR, 0, 1)

#define R_MAX (R_BBRAM_IDR + 1)

#define ZYNQMP_BBRAM_SIZE (8 * 4)
#define ZYNQMP_PGM_MAGIC_MASK 0x757bdf0d
#define IS_ZYNQMP (s->zynqmp_keysink)

#define ZYNQ3_PGM_MAGIC 0x757BDF0F

typedef struct BBRAMCtrl {
    SysBusDevice parent_obj;
    MemoryRegion iomem;
    qemu_irq irq_bbram;

    BlockBackend *blk;
    ZynqMPAESKeySink *zynqmp_keysink;
    uint32_t *ram32;
    uint32_t size;
    bool msw_lock;

    uint32_t regs[R_MAX];
    RegisterInfo regs_info[R_MAX];
} BBRAMCtrl;

static void bbram_ram_sync(BBRAMCtrl *s)
{
    /* Check if there is a ZynqMP key */
    if (IS_ZYNQMP) {
        if (0) {
            /* Real HW does only update the AES key at power on reset. */
            zynqmp_aes_key_update(s->zynqmp_keysink,
                                  (void *) &s->regs[R_BBRAM_0],
                                  ZYNQMP_BBRAM_SIZE);
        }
        return;
    }

    if (!s->blk) {
        return;
    }

    memcpy(s->ram32, &s->regs[R_BBRAM_0], (R_BBRAM_8 - R_BBRAM_0) * 4);
    if (blk_pwrite(s->blk, 0, (void *) s->ram32, s->size, 0) < 0) {
        error_report("%s: write error in sector", __func__);
    }
}

static void bbram_zeroize(BBRAMCtrl *s)
{
    DB_PRINT("Zeroing out the key\n");
    memset(&s->regs[R_BBRAM_0], 0, (R_BBRAM_8 - R_BBRAM_0) * 4);
    bbram_ram_sync(s);
}

static void bbram_update_irq(BBRAMCtrl *s)
{
    bool pending = s->regs[R_BBRAM_ISR] & ~s->regs[R_BBRAM_IMR];

    DB_PRINT("Setting the interrupt: %d\n", pending);
    qemu_set_irq(s->irq_bbram, pending);
}

static void bbram_ctrl_postw(RegisterInfo *reg, uint64_t val64)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(reg->opaque);
    uint32_t val = val64;

    if (val & R_BBRAM_CTRL_ZEROIZE_MASK) {
        bbram_zeroize(s);
        s->regs[R_BBRAM_STATUS] |= R_BBRAM_STATUS_BBRAM_ZEROIZED_MASK;
        /* The bit is self clearing */
        s->regs[R_BBRAM_CTRL] &= ~R_BBRAM_CTRL_ZEROIZE_MASK;
    }
}

static void bbram_pgm_mode_postw(RegisterInfo *reg, uint64_t val64)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(reg->opaque);
    uint32_t val = val64;

    if (val == ZYNQMP_PGM_MAGIC_MASK) {
        bbram_zeroize(s);
        s->regs[R_BBRAM_STATUS] |= R_BBRAM_STATUS_PGM_MODE_MASK;
    } else if (val == ZYNQ3_PGM_MAGIC) {
        bbram_zeroize(s);
        s->regs[R_BBRAM_STATUS] |= R_BBRAM_STATUS_PGM_MODE_MASK;
    }
}

static void bbram_aes_crc_postw(RegisterInfo *reg, uint64_t val64)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(reg->opaque);

    if (!(s->regs[R_BBRAM_STATUS] & R_BBRAM_STATUS_PGM_MODE_MASK)) {
        /* We are not in programming mode, don't do anything */
        return;
    }

    /* Perform the AES integrity check */
    s->regs[R_BBRAM_STATUS] |= R_BBRAM_STATUS_AES_CRC_DONE_MASK;

    /* If the value calculated by the BBRAM controller matches the value
     * written to this register the test passes. We don't know what the test
     * is so let's just pass it.
     */
    s->regs[R_BBRAM_STATUS] |= R_BBRAM_STATUS_AES_CRC_PASS_MASK;
}

static uint64_t bbram_key_prew(RegisterInfo *reg, uint64_t val64)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(reg->opaque);
    uint32_t original_data = *(uint32_t *) reg->data;

    if (s->regs[R_BBRAM_STATUS] & R_BBRAM_STATUS_PGM_MODE_MASK) {
        if (s->msw_lock) {
            DB_PRINT("MSW lock is set. Writing value: 0x%"HWADDR_PRIx"\n",
                     val64 & 0xFFFF);
            return val64 & 0xFFFF;
        } else {
            DB_PRINT("Writing value: 0x%"HWADDR_PRIx"\n", val64);
            return val64;
        }
    } else {
        /* We are not in programming mode, don't do anything */
        qemu_log_mask(LOG_GUEST_ERROR,
                      "Not in programming mode, dropping the write\n");
        return original_data;
    }
}

static void bbram_key_postw(RegisterInfo *reg, uint64_t val64)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(reg->opaque);

    if (IS_ZYNQMP) {
        zynqmp_aes_key_update(s->zynqmp_keysink, (void *) &s->regs[R_BBRAM_0],
                              ZYNQMP_BBRAM_SIZE);
    }
}

static void bbram_isr_postw(RegisterInfo *reg, uint64_t val64)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(reg->opaque);

    bbram_update_irq(s);
}

static uint64_t bbram_ier_prew(RegisterInfo *reg, uint64_t val64)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(reg->opaque);
    uint32_t val = val64;

    s->regs[R_BBRAM_IMR] &= ~val;
    bbram_update_irq(s);
    return 0;
}

static uint64_t bbram_idr_prew(RegisterInfo *reg, uint64_t val64)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(reg->opaque);
    uint32_t val = val64;

    s->regs[R_BBRAM_IMR] |= val;
    bbram_update_irq(s);
    return 0;
}

static RegisterAccessInfo bbram_ctrl_regs_info[] = {
    {   .name = "BBRAM_STATUS",  .addr = A_BBRAM_STATUS,
        .rsvd = 0xee,
        .ro = 0x3ff,
    },{ .name = "BBRAM_CTRL",  .addr = A_BBRAM_CTRL,
        .post_write = bbram_ctrl_postw,
    },{ .name = "PGM_MODE",  .addr = A_PGM_MODE,
        .post_write = bbram_pgm_mode_postw,
    },{ .name = "BBRAM_AES_CRC",  .addr = A_BBRAM_AES_CRC,
        .post_write = bbram_aes_crc_postw,
    },{ .name = "BBRAM_0",  .addr = A_BBRAM_0,
        .pre_write = bbram_key_prew,
        .post_write = bbram_key_postw,
    },{ .name = "BBRAM_1",  .addr = A_BBRAM_1,
        .pre_write = bbram_key_prew,
        .post_write = bbram_key_postw,
    },{ .name = "BBRAM_2",  .addr = A_BBRAM_2,
        .pre_write = bbram_key_prew,
        .post_write = bbram_key_postw,
    },{ .name = "BBRAM_3",  .addr = A_BBRAM_3,
        .pre_write = bbram_key_prew,
        .post_write = bbram_key_postw,
    },{ .name = "BBRAM_4",  .addr = A_BBRAM_4,
        .pre_write = bbram_key_prew,
        .post_write = bbram_key_postw,
    },{ .name = "BBRAM_5",  .addr = A_BBRAM_5,
        .pre_write = bbram_key_prew,
        .post_write = bbram_key_postw,
    },{ .name = "BBRAM_6",  .addr = A_BBRAM_6,
        .pre_write = bbram_key_prew,
        .post_write = bbram_key_postw,
    },{ .name = "BBRAM_7",  .addr = A_BBRAM_7,
        .pre_write = bbram_key_prew,
        .post_write = bbram_key_postw,
    },{ .name = "BBRAM_8",  .addr = A_BBRAM_8,
        .pre_write = bbram_key_prew,
        .post_write = bbram_key_postw,
    },{ .name = "BBRAM_SLVERR",  .addr = A_BBRAM_SLVERR,
    },{ .name = "BBRAM_ISR",  .addr = A_BBRAM_ISR,
        .w1c = 0x1,
        .post_write = bbram_isr_postw,
    },{ .name = "BBRAM_IMR",  .addr = A_BBRAM_IMR,
        .ro = 0x1,
    },{ .name = "BBRAM_IER",  .addr = A_BBRAM_IER,
        .pre_write = bbram_ier_prew,
    },{ .name = "BBRAM_IDR",  .addr = A_BBRAM_IDR,
        .pre_write = bbram_idr_prew,
    }
};

static void bbram_ctrl_reset(DeviceState *dev)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(dev);
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(s->regs_info); ++i) {
        if (i < R_BBRAM_0 || i > R_BBRAM_8) {
            register_reset(&s->regs_info[i]);
        }
    }

    if (IS_ZYNQMP) {
        zynqmp_aes_key_update(s->zynqmp_keysink, (void *) &s->regs[R_BBRAM_0],
                              ZYNQMP_BBRAM_SIZE);
    }

    bbram_update_irq(s);
}

static const MemoryRegionOps bbram_ctrl_ops = {
    .read = register_read_memory,
    .write = register_write_memory,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static void bbram_ctrl_realize(DeviceState *dev, Error **errp)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(dev);
    DriveInfo *dinfo;
    BlockBackend *blk;
    const char *prefix = object_get_canonical_path(OBJECT(dev));

    if (!s->zynqmp_keysink) {
        error_setg(&error_abort,
                   "%s: AES BBRAM key sink not connected\n", prefix);
    }

    dinfo = drive_get_next(IF_PFLASH);
    blk = dinfo ? blk_by_legacy_dinfo(dinfo) : NULL;
    s->ram32 = g_malloc0(s->size);
    memset(s->ram32, 0, s->size);
    if (blk) {
        qdev_prop_set_drive(dev, "drive", blk, errp);
        if (!blk_pread(s->blk, 0, (void *) s->ram32, s->size)) {
            error_setg(&error_abort, "%s: Unable to read-out contents."
                         "backing file too small? Expecting %u bytes",
                          prefix, s->size);
        }
    }
    memcpy(&s->regs[R_BBRAM_0], s->ram32, (R_BBRAM_8 - R_BBRAM_0) * 4);
}

static void bbram_ctrl_init(Object *obj)
{
    BBRAMCtrl *s = XILINX_BBRAM_CTRL(obj);
    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
    RegisterInfoArray *reg_array;

    memory_region_init(&s->iomem, obj, TYPE_XILINX_BBRAM_CTRL, R_MAX * 4);
    reg_array =
        register_init_block32(DEVICE(obj), bbram_ctrl_regs_info,
                              ARRAY_SIZE(bbram_ctrl_regs_info),
                              s->regs_info, s->regs,
                              &bbram_ctrl_ops,
                              XILINX_BBRAM_CTRL_ERR_DEBUG,
                              R_MAX * 4);
    memory_region_add_subregion(&s->iomem, 0x0, &reg_array->mem);

    sysbus_init_mmio(sbd, &s->iomem);
    sysbus_init_irq(sbd, &s->irq_bbram);
}

static const VMStateDescription vmstate_bbram_ctrl = {
    .name = TYPE_XILINX_BBRAM_CTRL,
    .version_id = 1,
    .minimum_version_id = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32_ARRAY(regs, BBRAMCtrl, R_MAX),
        VMSTATE_END_OF_LIST(),
    }
};

static Property bbram_ctrl_props[] = {
    DEFINE_PROP_LINK("zynqmp-aes-key-sink-bbram", BBRAMCtrl, zynqmp_keysink,
                     TYPE_ZYNQMP_AES_KEY_SINK, ZynqMPAESKeySink *),
    DEFINE_PROP_UINT32("bbram-size", BBRAMCtrl, size, ZYNQMP_BBRAM_SIZE),
    DEFINE_PROP_DRIVE("drive", BBRAMCtrl, blk),
    DEFINE_PROP_END_OF_LIST(),
};

static void bbram_ctrl_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->reset = bbram_ctrl_reset;
    dc->realize = bbram_ctrl_realize;
    dc->vmsd = &vmstate_bbram_ctrl;
    dc->props = bbram_ctrl_props;
}

static const TypeInfo bbram_ctrl_info = {
    .name          = TYPE_XILINX_BBRAM_CTRL,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(BBRAMCtrl),
    .class_init    = bbram_ctrl_class_init,
    .instance_init = bbram_ctrl_init,
};

static void bbram_ctrl_register_types(void)
{
    type_register_static(&bbram_ctrl_info);
}

type_init(bbram_ctrl_register_types)
