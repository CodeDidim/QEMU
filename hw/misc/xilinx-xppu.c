/*
 * QEMU model of the XPPU
 *
 * Copyright (c) 2014 - 2020 Xilinx Inc.
 *
 * Autogenerated by xregqemu.py 2019-12-05.
 * Written by Edgar E. Iglesias <edgar.iglesias@xilinx.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "qemu/osdep.h"
#include "hw/sysbus.h"
#include "hw/register.h"
#include "qemu/bitops.h"
#include "sysemu/dma.h"
#include "qapi/error.h"
#include "qemu/log.h"
#include "migration/vmstate.h"
#include "hw/qdev-properties.h"

#include "hw/fdt_generic_util.h"

#ifndef XILINX_XPPU_ERR_DEBUG
#define XILINX_XPPU_ERR_DEBUG 0
#endif

#define TYPE_XILINX_XPPU "xlnx.xppu"

#define XILINX_XPPU(obj) \
     OBJECT_CHECK(XPPU, (obj), TYPE_XILINX_XPPU)

REG32(CTRL, 0x0)
    FIELD(CTRL, APER_PARITY_EN, 2, 1)
    FIELD(CTRL, MID_PARITY_EN, 1, 1)
    FIELD(CTRL, ENABLE, 0, 1)
REG32(ERR_STATUS1, 0x4)
    FIELD(ERR_STATUS1, AXI_ADDR, 0, 20)
REG32(ERR_STATUS2, 0x8)
    FIELD(ERR_STATUS2, AXI_ID, 0, 10)
REG32(POISON, 0xc)
    FIELD(POISON, BASE, 0, 20)
REG32(ISR, 0x10)
    FIELD(ISR, APER_PARITY, 7, 1)
    FIELD(ISR, APER_TZ, 6, 1)
    FIELD(ISR, APER_PERM, 5, 1)
    FIELD(ISR, MID_PARITY, 3, 1)
    FIELD(ISR, MID_RO, 2, 1)
    FIELD(ISR, MID_MISS, 1, 1)
    FIELD(ISR, INV_APB, 0, 1)
REG32(IMR, 0x14)
    FIELD(IMR, APER_PARITY, 7, 1)
    FIELD(IMR, APER_TZ, 6, 1)
    FIELD(IMR, APER_PERM, 5, 1)
    FIELD(IMR, MID_PARITY, 3, 1)
    FIELD(IMR, MID_RO, 2, 1)
    FIELD(IMR, MID_MISS, 1, 1)
    FIELD(IMR, INV_APB, 0, 1)
REG32(IEN, 0x18)
    FIELD(IEN, APER_PARITY, 7, 1)
    FIELD(IEN, APER_TZ, 6, 1)
    FIELD(IEN, APER_PERM, 5, 1)
    FIELD(IEN, MID_PARITY, 3, 1)
    FIELD(IEN, MID_RO, 2, 1)
    FIELD(IEN, MID_MISS, 1, 1)
    FIELD(IEN, INV_APB, 0, 1)
REG32(IDS, 0x1c)
    FIELD(IDS, APER_PARITY, 7, 1)
    FIELD(IDS, APER_TZ, 6, 1)
    FIELD(IDS, APER_PERM, 5, 1)
    FIELD(IDS, MID_PARITY, 3, 1)
    FIELD(IDS, MID_RO, 2, 1)
    FIELD(IDS, MID_MISS, 1, 1)
    FIELD(IDS, INV_APB, 0, 1)
REG32(M_MASTER_IDS, 0x3c)
REG32(M_APERTURE_32B, 0x40)
REG32(M_APERTURE_64KB, 0x44)
REG32(M_APERTURE_1MB, 0x48)
REG32(M_APERTURE_512MB, 0x4c)
REG32(BASE_32B, 0x50)
REG32(BASE_64KB, 0x54)
REG32(BASE_1MB, 0x58)
REG32(BASE_512MB, 0x5c)
REG32(MASTER_ID00, 0x100)
    FIELD(MASTER_ID00, MIDP, 31, 1)
    FIELD(MASTER_ID00, MIDR, 30, 1)
    FIELD(MASTER_ID00, MIDM, 16, 10)
    FIELD(MASTER_ID00, MID, 0, 10)
REG32(MASTER_ID01, 0x104)
    FIELD(MASTER_ID01, MIDP, 31, 1)
    FIELD(MASTER_ID01, MIDR, 30, 1)
    FIELD(MASTER_ID01, MIDM, 16, 10)
    FIELD(MASTER_ID01, MID, 0, 10)
REG32(MASTER_ID02, 0x108)
    FIELD(MASTER_ID02, MIDP, 31, 1)
    FIELD(MASTER_ID02, MIDR, 30, 1)
    FIELD(MASTER_ID02, MIDM, 16, 10)
    FIELD(MASTER_ID02, MID, 0, 10)
REG32(MASTER_ID03, 0x10c)
    FIELD(MASTER_ID03, MIDP, 31, 1)
    FIELD(MASTER_ID03, MIDR, 30, 1)
    FIELD(MASTER_ID03, MIDM, 16, 10)
    FIELD(MASTER_ID03, MID, 0, 10)
REG32(MASTER_ID04, 0x110)
    FIELD(MASTER_ID04, MIDP, 31, 1)
    FIELD(MASTER_ID04, MIDR, 30, 1)
    FIELD(MASTER_ID04, MIDM, 16, 10)
    FIELD(MASTER_ID04, MID, 0, 10)
REG32(MASTER_ID05, 0x114)
    FIELD(MASTER_ID05, MIDP, 31, 1)
    FIELD(MASTER_ID05, MIDR, 30, 1)
    FIELD(MASTER_ID05, MIDM, 16, 10)
    FIELD(MASTER_ID05, MID, 0, 10)
REG32(MASTER_ID06, 0x118)
    FIELD(MASTER_ID06, MIDP, 31, 1)
    FIELD(MASTER_ID06, MIDR, 30, 1)
    FIELD(MASTER_ID06, MIDM, 16, 10)
    FIELD(MASTER_ID06, MID, 0, 10)
REG32(MASTER_ID07, 0x11c)
    FIELD(MASTER_ID07, MIDP, 31, 1)
    FIELD(MASTER_ID07, MIDR, 30, 1)
    FIELD(MASTER_ID07, MIDM, 16, 10)
    FIELD(MASTER_ID07, MID, 0, 10)
REG32(MASTER_ID08, 0x120)
    FIELD(MASTER_ID08, MIDP, 31, 1)
    FIELD(MASTER_ID08, MIDR, 30, 1)
    FIELD(MASTER_ID08, MIDM, 16, 10)
    FIELD(MASTER_ID08, MID, 0, 10)
REG32(MASTER_ID09, 0x124)
    FIELD(MASTER_ID09, MIDP, 31, 1)
    FIELD(MASTER_ID09, MIDR, 30, 1)
    FIELD(MASTER_ID09, MIDM, 16, 10)
    FIELD(MASTER_ID09, MID, 0, 10)
REG32(MASTER_ID10, 0x128)
    FIELD(MASTER_ID10, MIDP, 31, 1)
    FIELD(MASTER_ID10, MIDR, 30, 1)
    FIELD(MASTER_ID10, MIDM, 16, 10)
    FIELD(MASTER_ID10, MID, 0, 10)
REG32(MASTER_ID11, 0x12c)
    FIELD(MASTER_ID11, MIDP, 31, 1)
    FIELD(MASTER_ID11, MIDR, 30, 1)
    FIELD(MASTER_ID11, MIDM, 16, 10)
    FIELD(MASTER_ID11, MID, 0, 10)
REG32(MASTER_ID12, 0x130)
    FIELD(MASTER_ID12, MIDP, 31, 1)
    FIELD(MASTER_ID12, MIDR, 30, 1)
    FIELD(MASTER_ID12, MIDM, 16, 10)
    FIELD(MASTER_ID12, MID, 0, 10)
REG32(MASTER_ID13, 0x134)
    FIELD(MASTER_ID13, MIDP, 31, 1)
    FIELD(MASTER_ID13, MIDR, 30, 1)
    FIELD(MASTER_ID13, MIDM, 16, 10)
    FIELD(MASTER_ID13, MID, 0, 10)
REG32(MASTER_ID14, 0x138)
    FIELD(MASTER_ID14, MIDP, 31, 1)
    FIELD(MASTER_ID14, MIDR, 30, 1)
    FIELD(MASTER_ID14, MIDM, 16, 10)
    FIELD(MASTER_ID14, MID, 0, 10)
REG32(MASTER_ID15, 0x13c)
    FIELD(MASTER_ID15, MIDP, 31, 1)
    FIELD(MASTER_ID15, MIDR, 30, 1)
    FIELD(MASTER_ID15, MIDM, 16, 10)
    FIELD(MASTER_ID15, MID, 0, 10)
REG32(MASTER_ID16, 0x140)
    FIELD(MASTER_ID16, MIDP, 31, 1)
    FIELD(MASTER_ID16, MIDR, 30, 1)
    FIELD(MASTER_ID16, MIDM, 16, 10)
    FIELD(MASTER_ID16, MID, 0, 10)
REG32(MASTER_ID17, 0x144)
    FIELD(MASTER_ID17, MIDP, 31, 1)
    FIELD(MASTER_ID17, MIDR, 30, 1)
    FIELD(MASTER_ID17, MIDM, 16, 10)
    FIELD(MASTER_ID17, MID, 0, 10)
REG32(MASTER_ID18, 0x148)
    FIELD(MASTER_ID18, MIDP, 31, 1)
    FIELD(MASTER_ID18, MIDR, 30, 1)
    FIELD(MASTER_ID18, MIDM, 16, 10)
    FIELD(MASTER_ID18, MID, 0, 10)
REG32(MASTER_ID19, 0x14c)
    FIELD(MASTER_ID19, MIDP, 31, 1)
    FIELD(MASTER_ID19, MIDR, 30, 1)
    FIELD(MASTER_ID19, MIDM, 16, 10)
    FIELD(MASTER_ID19, MID, 0, 10)
REG32(RAM_ADJ, 0x1fc)
    FIELD(RAM_ADJ, MESSAGE_EMAS, 13, 1)
    FIELD(RAM_ADJ, MESSAGE_EMAW, 11, 2)
    FIELD(RAM_ADJ, MESSAGE_EMA, 8, 3)
    FIELD(RAM_ADJ, PERMISSION_EMAS, 5, 1)
    FIELD(RAM_ADJ, PERMISSION_EMAW, 3, 2)
    FIELD(RAM_ADJ, PERMISSION_EMA, 0, 3)

#define XPPU_R_MAX (R_RAM_ADJ + 1)

#define NR_MID_ENTRIES 20

#define NR_32B_APL_ENTRIES 128
#define NR_64K_APL_ENTRIES 256
#define NR_1M_APL_ENTRIES 16
#define NR_512M_APL_ENTRIES 1
#define NR_APL_ENTRIES (NR_32B_APL_ENTRIES + NR_64K_APL_ENTRIES \
                        + NR_1M_APL_ENTRIES + NR_512M_APL_ENTRIES)

typedef enum {
    GRANULE_32B,
    GRANULE_64K,
    GRANULE_1M,
    GRANULE_512M,
} XPPUGranule;

typedef struct XPPU XPPU;

typedef struct XPPUAperture {
    XPPU *parent;
    MemoryRegion iomem;

    XPPUGranule granule;
    /* MR base so we can offset the forwarded access.  */
    uint64_t base;
    /* Mask used to extract parts of the incoming address.  */
    uint64_t extract_mask;
    uint64_t extract_shift;
    /* RAM base. Start of APL tables for this particular Aperture.  */
    uint32_t ram_base;
} XPPUAperture;

struct XPPU {
    SysBusDevice parent_obj;
    MemoryRegion iomem;
    MemoryRegion perm_ram_iomem;
    qemu_irq irq_isr;

    MemoryRegion *mr;
    AddressSpace as;

    XPPUAperture ap[4];

    uint32_t perm_ram[NR_APL_ENTRIES];

    uint32_t regs[XPPU_R_MAX];
    RegisterInfo regs_info[XPPU_R_MAX];
};

static bool parity32(uint32_t v)
{
    /* We compute the parity in parallel, folding
     * each result in half, all the way down to one last bit.
     */
    v = v ^ (v >> 16);
    v = v ^ (v >> 8);
    v = v ^ (v >> 4);
    v = v ^ (v >> 2);
    v = v ^ (v >> 1);
    return v & 1;
}

static bool check_mid_parity(XPPU *s, uint32_t val32)
{
    static const uint32_t rsvd = 0x3c00fc00;
    bool p_written;
    bool p_computed;

    if (!ARRAY_FIELD_EX32(s->regs, CTRL, MID_PARITY_EN)) {
        return true;
    }

    /* Save the written parity.  */
    p_written = val32 & 0x80000000;

    /* Mask off parity field.  */
    val32 &= ~0x80000000;
    /* Mask off rsvd fields.  */
    val32 &= ~rsvd;
    p_computed = parity32(val32);

    return p_written == p_computed;
}

static void check_mid_parities(XPPU *s)
{
    unsigned int i;

    for (i = 0; i < NR_MID_ENTRIES; i++) {
        uint32_t val32;

        val32 = s->regs[R_MASTER_ID00 + i];

        /* Check MID parity.  */
        if (check_mid_parity(s, val32) == false) {
            ARRAY_FIELD_DP32(s->regs, ISR, MID_PARITY, true);
            continue;
        }
    }
}

static bool check_apl_parity(XPPU *s, uint32_t val32)
{
    unsigned int i;
    /* Bit 31 - Parity of 27, 19:15.
     * Bit 30 - Parity of 14:10
     * Bit 29 - Parity of 9:5
     * Bit 28 - Parity of 4:0
     */
    static const uint32_t apl_parities[] = {
        0x1f,
        0x1f << 5,
        0x1f << 10,
        (0x1f << 15) | 1 << 27,
    };
    uint32_t p = 0, p_written;
    bool ok;

    if (!ARRAY_FIELD_EX32(s->regs, CTRL, APER_PARITY_EN)) {
        return true;
    }

    for (i = 0; i < ARRAY_SIZE(apl_parities); i++) {
        uint32_t v = val32;
        bool parity;

        /* Extract the lanes for this pairity.  */
        v &= apl_parities[i];
        parity = parity32(v);
        p |= ((int) parity) << i;
    }

    p_written = val32 >> 28;
    ok = p_written == p;

    if (!ok) {
        qemu_log_mask(LOG_GUEST_ERROR, "Bad APL parity!\n");
        ARRAY_FIELD_DP32(s->regs, ISR, APER_PARITY, true);
    }
    return ok;
}

static void isr_update_irq(XPPU *s)
{
    bool pending = s->regs[R_ISR] & ~s->regs[R_IMR];
    qemu_set_irq(s->irq_isr, pending);
}

static void isr_postw(RegisterInfo *reg, uint64_t val64)
{
    XPPU *s = XILINX_XPPU(reg->opaque);
    isr_update_irq(s);
}

static uint64_t ien_prew(RegisterInfo *reg, uint64_t val64)
{
    XPPU *s = XILINX_XPPU(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IMR] &= ~val;
    isr_update_irq(s);
    return 0;
}

static uint64_t ids_prew(RegisterInfo *reg, uint64_t val64)
{
    XPPU *s = XILINX_XPPU(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IMR] |= val;
    isr_update_irq(s);
    return 0;
}

static void update_mrs(XPPU *s)
{
    bool xppu_enabled = ARRAY_FIELD_EX32(s->regs, CTRL, ENABLE);
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(s->ap); i++) {
        memory_region_set_enabled(&s->ap[i].iomem, xppu_enabled);
    }
}

static void ctrl_postw(RegisterInfo *reg, uint64_t val64)
{
    XPPU *s = XILINX_XPPU(reg->opaque);
    update_mrs(s);
    check_mid_parities(s);
    isr_update_irq(s);
}

static void mid_postw(RegisterInfo *reg, uint64_t val64)
{
    XPPU *s = XILINX_XPPU(reg->opaque);
    check_mid_parity(s, val64);
    isr_update_irq(s);
}

static const RegisterAccessInfo xppu_regs_info[] = {
    {   .name = "CTRL",  .addr = A_CTRL,
        .rsvd = 0xfffffff8,
        .ro = 0xfffffff8,
        .post_write = ctrl_postw,
    },{ .name = "ERR_STATUS1",  .addr = A_ERR_STATUS1,
        .rsvd = 0xfff00000,
        .ro = 0xffffffff,
    },{ .name = "ERR_STATUS2",  .addr = A_ERR_STATUS2,
        .rsvd = 0xfffffc00,
        .ro = 0xffffffff,
    },{ .name = "POISON",  .addr = A_POISON,
        .reset = 0xff9c0,
        .rsvd = 0xfff00000,
        .ro = 0xffffffff,
    },{ .name = "ISR",  .addr = A_ISR,
        .rsvd = 0xffffff10,
        .ro = 0xffffff10,
        .w1c = 0xef,
        .post_write = isr_postw,
    },{ .name = "IMR",  .addr = A_IMR,
        .reset = 0xef,
        .rsvd = 0xffffff10,
        .ro = 0xffffffff,
    },{ .name = "IEN",  .addr = A_IEN,
        .rsvd = 0xffffff10,
        .ro = 0xffffff10,
        .pre_write = ien_prew,
    },{ .name = "IDS",  .addr = A_IDS,
        .rsvd = 0xffffff10,
        .ro = 0xffffff10,
        .pre_write = ids_prew,
    },{ .name = "M_MASTER_IDS",  .addr = A_M_MASTER_IDS,
        .reset = 0x14,
        .ro = 0xffffffff,
    },{ .name = "M_APERTURE_32B",  .addr = A_M_APERTURE_32B,
        .reset = 0x80,
        .ro = 0xffffffff,
    },{ .name = "M_APERTURE_64KB",  .addr = A_M_APERTURE_64KB,
        .reset = 0x100,
        .ro = 0xffffffff,
    },{ .name = "M_APERTURE_1MB",  .addr = A_M_APERTURE_1MB,
        .reset = 0x10,
        .ro = 0xffffffff,
    },{ .name = "M_APERTURE_512MB",  .addr = A_M_APERTURE_512MB,
        .reset = 0x1,
        .ro = 0xffffffff,
    },{ .name = "BASE_32B",  .addr = A_BASE_32B,
        .reset = 0xff990000,
        .ro = 0xffffffff,
    },{ .name = "BASE_64KB",  .addr = A_BASE_64KB,
        .reset = 0xff000000,
        .ro = 0xffffffff,
    },{ .name = "BASE_1MB",  .addr = A_BASE_1MB,
        .reset = 0xfe000000,
        .ro = 0xffffffff,
    },{ .name = "BASE_512MB",  .addr = A_BASE_512MB,
        .reset = 0xc0000000,
        .ro = 0xffffffff,
    },{ .name = "MASTER_ID00",  .addr = A_MASTER_ID00,
        .reset = 0x83ff0040,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
        .post_write = mid_postw,
    },{ .name = "MASTER_ID01",  .addr = A_MASTER_ID01,
        .reset = 0x3f00000,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
        .post_write = mid_postw,
    },{ .name = "MASTER_ID02",  .addr = A_MASTER_ID02,
        .reset = 0x83f00010,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
        .post_write = mid_postw,
    },{ .name = "MASTER_ID03",  .addr = A_MASTER_ID03,
        .reset = 0x83c00080,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
        .post_write = mid_postw,
    },{ .name = "MASTER_ID04",  .addr = A_MASTER_ID04,
        .reset = 0x83c30080,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID05",  .addr = A_MASTER_ID05,
        .reset = 0x3c30081,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID06",  .addr = A_MASTER_ID06,
        .reset = 0x3c30082,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID07",  .addr = A_MASTER_ID07,
        .reset = 0x83c30083,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID08",  .addr = A_MASTER_ID08,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID09",  .addr = A_MASTER_ID09,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID10",  .addr = A_MASTER_ID10,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID11",  .addr = A_MASTER_ID11,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID12",  .addr = A_MASTER_ID12,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID13",  .addr = A_MASTER_ID13,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID14",  .addr = A_MASTER_ID14,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID15",  .addr = A_MASTER_ID15,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID16",  .addr = A_MASTER_ID16,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID17",  .addr = A_MASTER_ID17,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID18",  .addr = A_MASTER_ID18,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "MASTER_ID19",  .addr = A_MASTER_ID19,
        .rsvd = 0x3c00fc00,
        .ro = 0x3c00fc00,
    },{ .name = "RAM_ADJ",  .addr = A_RAM_ADJ,
        .reset = 0xb0b,
        .rsvd = 0xffffc0c0,
        .ro = 0xffffc0c0,
    }
};

static void xppu_reset(DeviceState *dev)
{
    XPPU *s = XILINX_XPPU(dev);
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(s->regs_info); ++i) {
        register_reset(&s->regs_info[i]);
    }
    update_mrs(s);
    isr_update_irq(s);
}

static bool xppu_ap_check(XPPU *s, MemTxAttrs attr, bool rw, uint32_t apl)
{
    unsigned int i;
    bool mid_match = false;
    bool tz = extract32(apl, 27, 1);
    bool ok;

    ok = check_apl_parity(s, apl);
    if (!ok) {
        return false;
    }

    /* Check MIDs.  */
    for (i = 0; i < NR_MID_ENTRIES; i++) {
        uint32_t val32, mid, mask;
        bool readonly;

        if (!extract32(apl, i, 1)) {
            continue;
        }

        val32 = s->regs[R_MASTER_ID00 + i];
        mid = FIELD_EX32(val32, MASTER_ID00, MID);
        readonly = FIELD_EX32(val32, MASTER_ID00, MIDR);
        mask = FIELD_EX32(val32, MASTER_ID00, MIDM);

        if ((mid & mask) != (attr.requester_id & mask)) {
            continue;
        }

        mid_match = true;

        /* Check MID parity.  */
        if (check_mid_parity(s, val32) == false) {
            ARRAY_FIELD_DP32(s->regs, ISR, MID_PARITY, true);
            continue;
        }

        if (readonly && rw) {
            ARRAY_FIELD_DP32(s->regs, ISR, MID_RO, true);
            continue;
        }

        if (!attr.secure && !tz) {
            ARRAY_FIELD_DP32(s->regs, ISR, APER_TZ, true);
            continue;
        }

        break;
    }

    if (!mid_match) {
        /* Set if MID checks don't make it past masking and compare.  */
        ARRAY_FIELD_DP32(s->regs, ISR, MID_MISS, true);
    }

    return i < NR_MID_ENTRIES;
}

static void xppu_ap_access(void *opaque, hwaddr addr, uint64_t *value, bool rw,
                           unsigned size, MemTxAttrs attr)
{
    XPPUAperture *ap = opaque;
    XPPU *s = ap->parent;
    uint32_t ram_offset;
    uint32_t apl;
    bool valid;
    bool isr_free;
    bool xppu_enabled = ARRAY_FIELD_EX32(s->regs, CTRL, ENABLE);

    assert(xppu_enabled);

    addr += ap->base;

    /* If any of bits ISR[7:1] are set, we cant store new faults.  */
    isr_free = (s->regs[R_ISR] & 0xf6) == 0;

    ram_offset = addr & ap->extract_mask;
    ram_offset >>= ap->extract_shift;

    ram_offset += ap->ram_base;
    apl = s->perm_ram[ram_offset];
    valid = xppu_ap_check(s, attr, rw, apl);

    if (!valid) {
        if (isr_free) {
            ARRAY_FIELD_DP32(s->regs, ISR, APER_PERM, true);
            ARRAY_FIELD_DP32(s->regs, ERR_STATUS1, AXI_ADDR, addr >> 12);
            ARRAY_FIELD_DP32(s->regs, ERR_STATUS2, AXI_ID, attr.requester_id);
        }

        /* Poison the transaction.
         *
         * Bits 11:0  remain untouched.
         * Bits 31:12 are taken from the POISONBASE register
         * Bits 48:32 are zeroed.
         */
        addr &= (1 << 12) - 1;
        addr |= ARRAY_FIELD_EX32(s->regs, POISON, BASE) << 12;
        isr_update_irq(s);
    }

    /* The access is accepted, let it through.  */
    *value = cpu_to_le64(*value);
    address_space_rw(&s->as, addr, attr, (uint8_t *)value, size, rw);
    *value = le64_to_cpu(*value);
}

static MemTxResult xppu_ap_read(void *opaque, hwaddr addr, uint64_t *value,
                                unsigned size, MemTxAttrs attr)
{
    xppu_ap_access(opaque, addr, value, false, size, attr);

    return MEMTX_OK;
}

static MemTxResult xppu_ap_write(void *opaque, hwaddr addr, uint64_t value,
                                 unsigned size, MemTxAttrs attr)
{
    xppu_ap_access(opaque, addr, &value, true, size, attr);

    return MEMTX_OK;
}

static const MemoryRegionOps xppu_ap_ops = {
    .read_with_attrs = xppu_ap_read,
    .write_with_attrs = xppu_ap_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static XPPU *xppu_from_mr(void *mr_accessor)
{
    RegisterInfoArray *reg_array = mr_accessor;
    Object *obj;

    assert(reg_array != NULL);

    obj = reg_array->mem.owner;
    assert(obj);

    return XILINX_XPPU(obj);
}

static MemTxResult xppu_read(void *opaque, hwaddr addr, uint64_t *value,
                             unsigned size, MemTxAttrs attr)
{
    XPPU *s = xppu_from_mr(opaque);
    RegisterInfo *r;

    if (!attr.secure) {
        return MEMTX_ERROR;
    }

    r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: read from %" HWADDR_PRIx "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr);
        ARRAY_FIELD_DP32(s->regs, ISR, INV_APB, true);
        isr_update_irq(s);
        return MEMTX_DECODE_ERROR;
    }

    *value = register_read_memory(opaque, addr, size);
    return MEMTX_OK;
}

static MemTxResult xppu_write(void *opaque, hwaddr addr, uint64_t value,
                       unsigned size, MemTxAttrs attr)
{
    XPPU *s = xppu_from_mr(opaque);
    RegisterInfo *r;

    if (!attr.secure) {
        return MEMTX_ERROR;
    }

    r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: write to %" HWADDR_PRIx "=%" PRIx64 "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr, value);
        ARRAY_FIELD_DP32(s->regs, ISR, INV_APB, true);
        isr_update_irq(s);
        return MEMTX_DECODE_ERROR;
    }

    register_write_memory(opaque, addr, value, size);
    return MEMTX_OK;
}


static MemTxResult xppu_perm_ram_read(void *opaque, hwaddr addr, uint64_t *val,
                             unsigned size, MemTxAttrs attr)
{
    XPPU *s = XILINX_XPPU(opaque);
    unsigned int i;

    if (!attr.secure) {
        return MEMTX_ERROR;
    }

    i = addr / 4;
    if (i >= ARRAY_SIZE(s->perm_ram)) {
        qemu_log("%s: Decode error: read from %" HWADDR_PRIx "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr);
        ARRAY_FIELD_DP32(s->regs, ISR, INV_APB, true);
        isr_update_irq(s);
        return MEMTX_DECODE_ERROR;
    }

    *val = s->perm_ram[i];
    return MEMTX_OK;
}

static MemTxResult xppu_perm_ram_write(void *opaque, hwaddr addr, uint64_t val,
                              unsigned size, MemTxAttrs attr)
{
    XPPU *s = XILINX_XPPU(opaque);
    unsigned int i;

    if (!attr.secure) {
        return MEMTX_ERROR;
    }

    i = addr / 4;
    if (i >= ARRAY_SIZE(s->perm_ram)) {
        qemu_log("%s: Decode error: write to %" HWADDR_PRIx "=%" PRIx64 "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr, val);
        ARRAY_FIELD_DP32(s->regs, ISR, INV_APB, true);
        isr_update_irq(s);
        return MEMTX_DECODE_ERROR;
    }

    s->perm_ram[i] = val;
    return MEMTX_OK;
}

static const MemoryRegionOps xppu_ops = {
    .read_with_attrs = xppu_read,
    .write_with_attrs = xppu_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static const MemoryRegionOps xppu_perm_ram_ops = {
    .read_with_attrs = xppu_perm_ram_read,
    .write_with_attrs = xppu_perm_ram_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static void xppu_realize(DeviceState *dev, Error **errp)
{
    XPPU *s = XILINX_XPPU(dev);

    address_space_init(&s->as, s->mr ? s->mr : get_system_memory(),
                       object_get_canonical_path(OBJECT(dev)));
}

static void xppu_init(Object *obj)
{
    XPPU *s = XILINX_XPPU(obj);
    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
    RegisterInfoArray *reg_array;

    memory_region_init_io(&s->iomem, obj, &xppu_ops, s, TYPE_XILINX_XPPU,
                          0x10000);
    memory_region_init_io(&s->perm_ram_iomem, obj, &xppu_perm_ram_ops, s,
                          TYPE_XILINX_XPPU, 0xE000);
    reg_array =
        register_init_block32(DEVICE(obj), xppu_regs_info,
                              ARRAY_SIZE(xppu_regs_info),
                              s->regs_info, s->regs,
                              &xppu_ops,
                              XILINX_XPPU_ERR_DEBUG,
                              XPPU_R_MAX * 4);
    memory_region_add_subregion(&s->iomem,
                                0x0,
                                &reg_array->mem);
    memory_region_add_subregion(&s->iomem, 0x1000, &s->perm_ram_iomem);
    sysbus_init_mmio(sbd, &s->iomem);
    object_property_add_link(obj, "mr", TYPE_MEMORY_REGION,
                             (Object **)&s->mr,
                             qdev_prop_allow_set_link_before_realize,
                             OBJ_PROP_LINK_STRONG,
                             &error_abort);

    sysbus_init_irq(sbd, &s->irq_isr);
}

static bool xppu_parse_reg(FDTGenericMMap *obj, FDTGenericRegPropInfo reg,
                           Error **errp)
{
    XPPU *s = XILINX_XPPU(obj);
    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
    ObjectClass *klass = object_class_by_name(TYPE_XILINX_XPPU);
    FDTGenericMMapClass *parent_fmc;
    unsigned int i;

    parent_fmc = FDT_GENERIC_MMAP_CLASS(object_class_get_parent(klass));

    for (i = 0; i < (reg.n - 1) && i < ARRAY_SIZE(s->ap); i++) {
        static const XPPUGranule granules[] = {
            GRANULE_32B,
            GRANULE_64K,
            GRANULE_1M,
            GRANULE_512M
        };
        static const uint64_t bases[] = {
            0xff990000,
            0xff000000,
            0xfe000000,
            0xc0000000,
        };
        static const uint64_t masks[] = {
            0x7f << 5,  /* 32B, bits 11:05.  */
            0xff << 16, /* 64K, bits 23:16.  */
            0x0f << 20, /* 1MB, bits 23:20.  */
            0, /* No extraction.  */
        };
        static const unsigned int shifts[] = {
            5,  /* 32B, bits 11:05.  */
            16, /* 64K, bits 23:16.  */
            20, /* 1MB, bits 23:20.  */
            0, /* No extraction.  */
        };
        static const uint32_t ram_bases[] = {
            0x100,
            0x0,
            0x180,
            0x190,
        };
        char *name;

        s->ap[i].parent = s;
        s->ap[i].granule = granules[i];
        s->ap[i].base = bases[i];
        s->ap[i].extract_mask = masks[i];
        s->ap[i].extract_shift = shifts[i];
        s->ap[i].ram_base = ram_bases[i];

        name = g_strdup_printf("xppu-mr-%d\n", i);
        memory_region_init_io(&s->ap[i].iomem, OBJECT(obj),
                              &xppu_ap_ops, &s->ap[i],
                              name, reg.s[i + 1]);
        sysbus_init_mmio(sbd, &s->ap[i].iomem);
        g_free(name);
    }
    return parent_fmc ? parent_fmc->parse_reg(obj, reg, errp) : false;
}

static const VMStateDescription vmstate_xppu = {
    .name = TYPE_XILINX_XPPU,
    .version_id = 1,
    .minimum_version_id = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32_ARRAY(regs, XPPU, XPPU_R_MAX),
        VMSTATE_END_OF_LIST(),
    }
};

static void xppu_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    FDTGenericMMapClass *fmc = FDT_GENERIC_MMAP_CLASS(klass);

    dc->reset = xppu_reset;
    dc->realize = xppu_realize;
    dc->vmsd = &vmstate_xppu;
    fmc->parse_reg = xppu_parse_reg;
}

static const TypeInfo xppu_info = {
    .name          = TYPE_XILINX_XPPU,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(XPPU),
    .class_init    = xppu_class_init,
    .instance_init = xppu_init,
    .interfaces    = (InterfaceInfo[]) {
        { TYPE_FDT_GENERIC_MMAP },
        { },
    },

};

static void xppu_register_types(void)
{
    type_register_static(&xppu_info);
}

type_init(xppu_register_types)
