/*
 * QEMU model of the APU_CTRL APU Dual Core Settings
 *
 * Copyright (c) 2017 Xilinx Inc.
 *
 * Autogenerated by xregqemu.py 2017-03-31.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "qemu/osdep.h"
#include "hw/sysbus.h"
#include "hw/register-dep.h"
#include "qemu/bitops.h"
#include "qemu/log.h"
#include "qapi/error.h"
#include "sysemu/sysemu.h"
#include "cpu.h"

#ifndef XILINX_APU_CTRL_ERR_DEBUG
#define XILINX_APU_CTRL_ERR_DEBUG 0
#endif

#define TYPE_XILINX_APU_CTRL "xlnx.zynq3-apu-ctrl"

#define XILINX_APU_CTRL(obj) \
     OBJECT_CHECK(XlnxZynq3APUCtrl, (obj), TYPE_XILINX_APU_CTRL)

DEP_REG32(ERR_CTRL, 0x0)
    DEP_FIELD(ERR_CTRL, PSLVERR, 1, 0)
DEP_REG32(ISR, 0x10)
    DEP_FIELD(ISR, INV_APB, 1, 0)
DEP_REG32(IMR, 0x14)
    DEP_FIELD(IMR, INV_APB, 1, 0)
DEP_REG32(IEN, 0x18)
    DEP_FIELD(IEN, INV_APB, 1, 0)
DEP_REG32(IDS, 0x1c)
    DEP_FIELD(IDS, INV_APB, 1, 0)
DEP_REG32(CONFIG_0, 0x20)
    DEP_FIELD(CONFIG_0, CFGTE, 2, 24)
    DEP_FIELD(CONFIG_0, CFGEND, 2, 16)
    DEP_FIELD(CONFIG_0, VINITHI, 2, 8)
    DEP_FIELD(CONFIG_0, AA64NAA32, 2, 0)
DEP_REG32(CONFIG_1, 0x24)
    DEP_FIELD(CONFIG_1, L1RSTDISABLE, 1, 28)
    DEP_FIELD(CONFIG_1, CP15SDISABLE, 2, 0)
DEP_REG32(RVBARADDR0L, 0x40)
    DEP_FIELD(RVBARADDR0L, ADDR, 30, 2)
DEP_REG32(RVBARADDR0H, 0x44)
    DEP_FIELD(RVBARADDR0H, ADDR, 12, 0)
DEP_REG32(RVBARADDR1L, 0x48)
    DEP_FIELD(RVBARADDR1L, ADDR, 30, 2)
DEP_REG32(RVBARADDR1H, 0x4c)
    DEP_FIELD(RVBARADDR1H, ADDR, 12, 0)
DEP_REG32(ACE_CTRL, 0x60)
    DEP_FIELD(ACE_CTRL, AWQOS, 4, 16)
    DEP_FIELD(ACE_CTRL, ARQOS, 4, 0)
DEP_REG32(SNOOP_CTRL, 0x80)
    DEP_FIELD(SNOOP_CTRL, ACE_INACT, 1, 4)
    DEP_FIELD(SNOOP_CTRL, ACP_INACT, 1, 0)
DEP_REG32(PWRCTL, 0x90)
    DEP_FIELD(PWRCTL, CLREXMONREQ, 1, 17)
    DEP_FIELD(PWRCTL, L2FLUSHREQ, 1, 16)
    DEP_FIELD(PWRCTL, CPUPWRDWNREQ, 2, 0)
DEP_REG32(PWRSTAT, 0x94)
    DEP_FIELD(PWRSTAT, CLREXMONACK, 1, 17)
    DEP_FIELD(PWRSTAT, L2FLUSHDONE, 1, 16)
    DEP_FIELD(PWRSTAT, DBGNOPWRDWN, 2, 0)
DEP_REG32(ECO, 0xec)
DEP_REG32(RAM_ADJ_0, 0xf0)
    DEP_FIELD(RAM_ADJ_0, IF_BTB_EMAS, 1, 29)
    DEP_FIELD(RAM_ADJ_0, IF_BTB_EMAW, 2, 27)
    DEP_FIELD(RAM_ADJ_0, IF_BTB_EMA, 3, 24)
    DEP_FIELD(RAM_ADJ_0, IF_GHB_T3T4_EMAS, 1, 21)
    DEP_FIELD(RAM_ADJ_0, IF_GHB_T3T4_EMAW, 2, 19)
    DEP_FIELD(RAM_ADJ_0, IF_GHB_T3T4_EMA, 3, 16)
    DEP_FIELD(RAM_ADJ_0, IF_GHB_T1T2_EMAS, 1, 13)
    DEP_FIELD(RAM_ADJ_0, IF_GHB_T1T2_EMAW, 2, 11)
    DEP_FIELD(RAM_ADJ_0, IF_GHB_T1T2_EMA, 3, 8)
    DEP_FIELD(RAM_ADJ_0, IF_GHB_T0_EMAS, 1, 5)
    DEP_FIELD(RAM_ADJ_0, IF_GHB_T0_EMAW, 2, 3)
    DEP_FIELD(RAM_ADJ_0, IF_GHB_T0_EMA, 3, 0)
DEP_REG32(RAM_ADJ_1, 0xf4)
    DEP_FIELD(RAM_ADJ_1, LS_PF_PHT_EMAS, 1, 29)
    DEP_FIELD(RAM_ADJ_1, LS_PF_PHT_EMAW, 2, 27)
    DEP_FIELD(RAM_ADJ_1, LS_PF_PHT_EMA, 3, 24)
    DEP_FIELD(RAM_ADJ_1, IF_IP_EMAS, 1, 21)
    DEP_FIELD(RAM_ADJ_1, IF_IP_EMAW, 2, 19)
    DEP_FIELD(RAM_ADJ_1, IF_IP_EMA, 3, 16)
    DEP_FIELD(RAM_ADJ_1, IF_TAG_EMAS, 1, 13)
    DEP_FIELD(RAM_ADJ_1, IF_TAG_EMAW, 2, 11)
    DEP_FIELD(RAM_ADJ_1, IF_TAG_EMA, 3, 8)
    DEP_FIELD(RAM_ADJ_1, IF_DATA_EMAS, 1, 5)
    DEP_FIELD(RAM_ADJ_1, IF_DATA_EMAW, 2, 3)
    DEP_FIELD(RAM_ADJ_1, IF_DATA_EMA, 3, 0)
DEP_REG32(RAM_ADJ_2, 0xf8)
    DEP_FIELD(RAM_ADJ_2, L2_SNP_TAG_EMAS, 1, 29)
    DEP_FIELD(RAM_ADJ_2, L2_SNP_TAG_EMAW, 2, 27)
    DEP_FIELD(RAM_ADJ_2, L2_SNP_TAG_EMA, 3, 24)
    DEP_FIELD(RAM_ADJ_2, L2_TLB_EMAS, 1, 21)
    DEP_FIELD(RAM_ADJ_2, L2_TLB_EMAW, 2, 19)
    DEP_FIELD(RAM_ADJ_2, L2_TLB_EMA, 3, 16)
    DEP_FIELD(RAM_ADJ_2, LS_TAG_EMAS, 1, 13)
    DEP_FIELD(RAM_ADJ_2, LS_TAG_EMAW, 2, 11)
    DEP_FIELD(RAM_ADJ_2, LS_TAG_EMA, 3, 8)
    DEP_FIELD(RAM_ADJ_2, LS_DATA_EMAS, 1, 5)
    DEP_FIELD(RAM_ADJ_2, LS_DATA_EMAW, 2, 3)
    DEP_FIELD(RAM_ADJ_2, LS_DATA_EMA, 3, 0)
DEP_REG32(RAM_ADJ_3, 0xfc)
    DEP_FIELD(RAM_ADJ_3, L2_INCL_PLRU_EMAS, 1, 29)
    DEP_FIELD(RAM_ADJ_3, L2_INCL_PLRU_EMAW, 2, 27)
    DEP_FIELD(RAM_ADJ_3, L2_INCL_PLRU_EMA, 3, 24)
    DEP_FIELD(RAM_ADJ_3, L2_DIRTY_EMAS, 1, 21)
    DEP_FIELD(RAM_ADJ_3, L2_DIRTY_EMAW, 2, 19)
    DEP_FIELD(RAM_ADJ_3, L2_DIRTY_EMA, 3, 16)
    DEP_FIELD(RAM_ADJ_3, L2_TAG_EMAS, 1, 13)
    DEP_FIELD(RAM_ADJ_3, L2_TAG_EMAW, 2, 11)
    DEP_FIELD(RAM_ADJ_3, L2_TAG_EMA, 3, 8)
    DEP_FIELD(RAM_ADJ_3, L2_DATA_EMAS, 1, 5)
    DEP_FIELD(RAM_ADJ_3, L2_DATA_EMAW, 2, 3)
    DEP_FIELD(RAM_ADJ_3, L2_DATA_EMA, 3, 0)
DEP_REG32(RAM_ADJ_4, 0x100)
    DEP_FIELD(RAM_ADJ_4, ELA_EMAS, 1, 13)
    DEP_FIELD(RAM_ADJ_4, ELA_EMAW, 2, 11)
    DEP_FIELD(RAM_ADJ_4, ELA_EMA, 3, 8)
    DEP_FIELD(RAM_ADJ_4, ETF_EMAS, 1, 5)
    DEP_FIELD(RAM_ADJ_4, ETF_EMAW, 2, 3)
    DEP_FIELD(RAM_ADJ_4, ETF_EMA, 3, 0)
DEP_REG32(XPD_REG0, 0x600)
DEP_REG32(XPD_REG1, 0x604)
DEP_REG32(XPD_CTRL0, 0x608)
    DEP_FIELD(XPD_CTRL0, DELAY_SPARE, 5, 25)
    DEP_FIELD(XPD_CTRL0, CMP_SEL, 1, 24)
    DEP_FIELD(XPD_CTRL0, DELAY_CELL_TYPE, 5, 19)
    DEP_FIELD(XPD_CTRL0, DELAY_VT_TYPE, 2, 17)
    DEP_FIELD(XPD_CTRL0, DELAY_VALUE, 11, 6)
    DEP_FIELD(XPD_CTRL0, PATH_SEL, 6, 0)
DEP_REG32(XPD_CTRL1, 0x60c)
    DEP_FIELD(XPD_CTRL1, CLK_SPARE, 4, 12)
    DEP_FIELD(XPD_CTRL1, CLK_PHASE_SEL, 2, 10)
    DEP_FIELD(XPD_CTRL1, CLK_VT_TYPE, 2, 8)
    DEP_FIELD(XPD_CTRL1, CLK_CELL_TYPE, 2, 6)
    DEP_FIELD(XPD_CTRL1, CLK_INSERT_DLY, 4, 2)
    DEP_FIELD(XPD_CTRL1, CLK_SEL, 1, 0)
DEP_REG32(XPD_CTRL2, 0x614)
    DEP_FIELD(XPD_CTRL2, CTRL_SPARE, 2, 1)
    DEP_FIELD(XPD_CTRL2, ENABLE, 1, 0)
DEP_REG32(XPD_CTRL3, 0x618)
    DEP_FIELD(XPD_CTRL3, DCYCLE_CNT_VALUE, 12, 3)
    DEP_FIELD(XPD_CTRL3, DCYCLE_HIGH_LOW, 1, 2)
    DEP_FIELD(XPD_CTRL3, DCYCLE_CNT_CLR, 1, 1)
    DEP_FIELD(XPD_CTRL3, DCYCLE_START, 1, 0)
DEP_REG32(XPD_SOFT_RST, 0x61c)
    DEP_FIELD(XPD_SOFT_RST, CLK1, 1, 1)
    DEP_FIELD(XPD_SOFT_RST, CLK0, 1, 0)
DEP_REG32(XPD_STAT, 0x620)
    DEP_FIELD(XPD_STAT, CMP_RESULT, 1, 1)
    DEP_FIELD(XPD_STAT, CMP_DONE, 1, 0)

#define R_MAX (R_XPD_STAT + 1)

#define MAX_CPUS 4

typedef struct XlnxZynq3APUCtrl {
    SysBusDevice parent_obj;
    MemoryRegion iomem;
    qemu_irq irq_imr;

    ARMCPU *cpus[MAX_CPUS];

    uint32_t regs[R_MAX];
    DepRegisterInfo regs_info[R_MAX];
} XlnxZynq3APUCtrl;

static void imr_update_irq(XlnxZynq3APUCtrl *s)
{
    bool pending = s->regs[R_ISR] & ~s->regs[R_IMR];
    qemu_set_irq(s->irq_imr, pending);
}

static void isr_postw(DepRegisterInfo *reg, uint64_t val64)
{
    XlnxZynq3APUCtrl *s = XILINX_APU_CTRL(reg->opaque);
    imr_update_irq(s);
}

static uint64_t ien_prew(DepRegisterInfo *reg, uint64_t val64)
{
    XlnxZynq3APUCtrl *s = XILINX_APU_CTRL(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IMR] &= ~val;
    imr_update_irq(s);
    return 0;
}

static uint64_t ids_prew(DepRegisterInfo *reg, uint64_t val64)
{
    XlnxZynq3APUCtrl *s = XILINX_APU_CTRL(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IMR] |= val;
    imr_update_irq(s);
    return 0;
}

static void rvbar_postw(DepRegisterInfo *reg, uint64_t val64)
{
    XlnxZynq3APUCtrl *s = XILINX_APU_CTRL(reg->opaque);
    int i;

    for (i = 0; i < MIN(smp_cpus, MAX_CPUS); i++) {
        uint64_t rvbar;

        if (s->cpus[i]) {
            rvbar = s->regs[R_RVBARADDR0H + i * 2];
            rvbar <<= 32;
            rvbar |= s->regs[R_RVBARADDR0L + i * 2];

            object_property_set_int(OBJECT(s->cpus[i]), rvbar, "rvbar",
                                    &error_abort);
        }
    }
}

static DepRegisterAccessInfo apu_ctrl_regs_info[] = {
    {   .name = "ERR_CTRL",  .decode.addr = A_ERR_CTRL,
    },{ .name = "ISR",  .decode.addr = A_ISR,
        .w1c = 0x1,
        .post_write = isr_postw,
    },{ .name = "IMR",  .decode.addr = A_IMR,
        .reset = 0x1,
        .ro = 0x1,
    },{ .name = "IEN",  .decode.addr = A_IEN,
        .pre_write = ien_prew,
    },{ .name = "IDS",  .decode.addr = A_IDS,
        .pre_write = ids_prew,
    },{ .name = "CONFIG_0",  .decode.addr = A_CONFIG_0,
        .reset = 0x303,
    },{ .name = "CONFIG_1",  .decode.addr = A_CONFIG_1,
    },{ .name = "RVBARADDR0L",  .decode.addr = A_RVBARADDR0L,
        .reset = 0xffff0000,
        .post_write = rvbar_postw,
    },{ .name = "RVBARADDR0H",  .decode.addr = A_RVBARADDR0H,
        .post_write = rvbar_postw,
    },{ .name = "RVBARADDR1L",  .decode.addr = A_RVBARADDR1L,
        .reset = 0xffff0000,
        .post_write = rvbar_postw,
    },{ .name = "RVBARADDR1H",  .decode.addr = A_RVBARADDR1H,
        .post_write = rvbar_postw,
    },{ .name = "ACE_CTRL",  .decode.addr = A_ACE_CTRL,
        .reset = 0xf000f,
    },{ .name = "SNOOP_CTRL",  .decode.addr = A_SNOOP_CTRL,
    },{ .name = "PWRCTL",  .decode.addr = A_PWRCTL,
    },{ .name = "PWRSTAT",  .decode.addr = A_PWRSTAT,
        .ro = 0x30003,
    },{ .name = "ECO",  .decode.addr = A_ECO,
    },{ .name = "RAM_ADJ_0",  .decode.addr = A_RAM_ADJ_0,
        .reset = 0xa0a0a0a,
    },{ .name = "RAM_ADJ_1",  .decode.addr = A_RAM_ADJ_1,
        .reset = 0xa0a0a0a,
    },{ .name = "RAM_ADJ_2",  .decode.addr = A_RAM_ADJ_2,
        .reset = 0xa0a0a0a,
    },{ .name = "RAM_ADJ_3",  .decode.addr = A_RAM_ADJ_3,
        .reset = 0xa0a0a0a,
    },{ .name = "RAM_ADJ_4",  .decode.addr = A_RAM_ADJ_4,
        .reset = 0xa0a,
    },{ .name = "XPD_REG0",  .decode.addr = A_XPD_REG0,
    },{ .name = "XPD_REG1",  .decode.addr = A_XPD_REG1,
    },{ .name = "XPD_CTRL0",  .decode.addr = A_XPD_CTRL0,
    },{ .name = "XPD_CTRL1",  .decode.addr = A_XPD_CTRL1,
    },{ .name = "XPD_CTRL2",  .decode.addr = A_XPD_CTRL2,
    },{ .name = "XPD_CTRL3",  .decode.addr = A_XPD_CTRL3,
        .ro = 0x7ff8,
    },{ .name = "XPD_SOFT_RST",  .decode.addr = A_XPD_SOFT_RST,
    },{ .name = "XPD_STAT",  .decode.addr = A_XPD_STAT,
        .ro = 0x3,
    }
};

static void apu_ctrl_reset(DeviceState *dev)
{
    XlnxZynq3APUCtrl *s = XILINX_APU_CTRL(dev);
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(s->regs_info); ++i) {
        dep_register_reset(&s->regs_info[i]);
    }

    imr_update_irq(s);
}

static uint64_t apu_ctrl_read(void *opaque, hwaddr addr, unsigned size)
{
    XlnxZynq3APUCtrl *s = XILINX_APU_CTRL(opaque);
    DepRegisterInfo *r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: read from %" HWADDR_PRIx "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr);
        return 0;
    }
    return dep_register_read(r);
}

static void apu_ctrl_write(void *opaque, hwaddr addr, uint64_t value,
                      unsigned size)
{
    XlnxZynq3APUCtrl *s = XILINX_APU_CTRL(opaque);
    DepRegisterInfo *r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: write to %" HWADDR_PRIx "=%" PRIx64 "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr, value);
        return;
    }
    dep_register_write(r, value, ~0);
}

static const MemoryRegionOps apu_ctrl_ops = {
    .read = apu_ctrl_read,
    .write = apu_ctrl_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static void apu_ctrl_realize(DeviceState *dev, Error **errp)
{
    XlnxZynq3APUCtrl *s = XILINX_APU_CTRL(dev);
    const char *prefix = object_get_canonical_path(OBJECT(dev));
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(apu_ctrl_regs_info); ++i) {
        DepRegisterInfo *r;

        r = &s->regs_info[apu_ctrl_regs_info[i].decode.addr / 4];
        *r = (DepRegisterInfo) {
            .data = (uint8_t *)&s->regs[
                    apu_ctrl_regs_info[i].decode.addr / 4],
            .data_size = sizeof(uint32_t),
            .access = &apu_ctrl_regs_info[i],
            .debug = XILINX_APU_CTRL_ERR_DEBUG,
            .prefix = prefix,
            .opaque = s,
        };
    }
}

static void apu_ctrl_init(Object *obj)
{
    XlnxZynq3APUCtrl *s = XILINX_APU_CTRL(obj);
    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
    int i;

    for (i = 0; i < MAX_CPUS; ++i) {
        char *prop_name = g_strdup_printf("cpu%d", i);
        object_property_add_link(obj, prop_name, TYPE_ARM_CPU,
                                 (Object **)&s->cpus[i],
                                 qdev_prop_allow_set_link_before_realize,
                                 OBJ_PROP_LINK_UNREF_ON_RELEASE,
                                 &error_abort);
        g_free(prop_name);
    }

    memory_region_init_io(&s->iomem, obj, &apu_ctrl_ops, s,
                          TYPE_XILINX_APU_CTRL, R_MAX * 4);
    sysbus_init_mmio(sbd, &s->iomem);
    sysbus_init_irq(sbd, &s->irq_imr);
}

static const VMStateDescription vmstate_apu_ctrl = {
    .name = TYPE_XILINX_APU_CTRL,
    .version_id = 1,
    .minimum_version_id = 1,
    .minimum_version_id_old = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32_ARRAY(regs, XlnxZynq3APUCtrl, R_MAX),
        VMSTATE_END_OF_LIST(),
    }
};

static void apu_ctrl_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->reset = apu_ctrl_reset;
    dc->realize = apu_ctrl_realize;
    dc->vmsd = &vmstate_apu_ctrl;
}

static const TypeInfo apu_ctrl_info = {
    .name          = TYPE_XILINX_APU_CTRL,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(XlnxZynq3APUCtrl),
    .class_init    = apu_ctrl_class_init,
    .instance_init = apu_ctrl_init,
};

static void apu_ctrl_register_types(void)
{
    type_register_static(&apu_ctrl_info);
}

type_init(apu_ctrl_register_types)
