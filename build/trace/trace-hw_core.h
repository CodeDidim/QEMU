/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_CORE_GENERATED_TRACERS_H
#define TRACE_HW_CORE_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_LOADER_WRITE_ROM_EVENT;
extern TraceEvent _TRACE_QDEV_UPDATE_PARENT_BUS_EVENT;
extern TraceEvent _TRACE_RESETTABLE_RESET_EVENT;
extern TraceEvent _TRACE_RESETTABLE_RESET_ASSERT_BEGIN_EVENT;
extern TraceEvent _TRACE_RESETTABLE_RESET_ASSERT_END_EVENT;
extern TraceEvent _TRACE_RESETTABLE_RESET_RELEASE_BEGIN_EVENT;
extern TraceEvent _TRACE_RESETTABLE_RESET_RELEASE_END_EVENT;
extern TraceEvent _TRACE_RESETTABLE_CHANGE_PARENT_EVENT;
extern TraceEvent _TRACE_RESETTABLE_PHASE_ENTER_BEGIN_EVENT;
extern TraceEvent _TRACE_RESETTABLE_PHASE_ENTER_EXEC_EVENT;
extern TraceEvent _TRACE_RESETTABLE_PHASE_ENTER_END_EVENT;
extern TraceEvent _TRACE_RESETTABLE_PHASE_HOLD_BEGIN_EVENT;
extern TraceEvent _TRACE_RESETTABLE_PHASE_HOLD_EXEC_EVENT;
extern TraceEvent _TRACE_RESETTABLE_PHASE_HOLD_END_EVENT;
extern TraceEvent _TRACE_RESETTABLE_PHASE_EXIT_BEGIN_EVENT;
extern TraceEvent _TRACE_RESETTABLE_PHASE_EXIT_EXEC_EVENT;
extern TraceEvent _TRACE_RESETTABLE_PHASE_EXIT_END_EVENT;
extern TraceEvent _TRACE_RESETTABLE_TRANSITIONAL_FUNCTION_EVENT;
extern TraceEvent _TRACE_CLOCK_SET_SOURCE_EVENT;
extern TraceEvent _TRACE_CLOCK_DISCONNECT_EVENT;
extern TraceEvent _TRACE_CLOCK_SET_EVENT;
extern TraceEvent _TRACE_CLOCK_PROPAGATE_EVENT;
extern TraceEvent _TRACE_CLOCK_UPDATE_EVENT;
extern TraceEvent _TRACE_CLOCK_SET_MUL_DIV_EVENT;
extern TraceEvent _TRACE_CPU_RESET_EVENT;
extern TraceEvent _TRACE_REMOTE_PORT_MEMORY_MASTER_TX_BUSACCESS_EVENT;
extern TraceEvent _TRACE_REMOTE_PORT_MEMORY_MASTER_RX_BUSACCESS_EVENT;
extern TraceEvent _TRACE_REMOTE_PORT_MEMORY_SLAVE_TX_BUSACCESS_EVENT;
extern TraceEvent _TRACE_REMOTE_PORT_MEMORY_SLAVE_RX_BUSACCESS_EVENT;
extern TraceEvent _TRACE_REMOTE_PORT_GPIO_TX_INTERRUPT_EVENT;
extern TraceEvent _TRACE_REMOTE_PORT_GPIO_RX_INTERRUPT_EVENT;
extern TraceEvent _TRACE_REMOTE_PORT_STREAM_TX_BUSACCESS_EVENT;
extern TraceEvent _TRACE_REMOTE_PORT_STREAM_RX_BUSACCESS_EVENT;
extern uint16_t _TRACE_LOADER_WRITE_ROM_DSTATE;
extern uint16_t _TRACE_QDEV_UPDATE_PARENT_BUS_DSTATE;
extern uint16_t _TRACE_RESETTABLE_RESET_DSTATE;
extern uint16_t _TRACE_RESETTABLE_RESET_ASSERT_BEGIN_DSTATE;
extern uint16_t _TRACE_RESETTABLE_RESET_ASSERT_END_DSTATE;
extern uint16_t _TRACE_RESETTABLE_RESET_RELEASE_BEGIN_DSTATE;
extern uint16_t _TRACE_RESETTABLE_RESET_RELEASE_END_DSTATE;
extern uint16_t _TRACE_RESETTABLE_CHANGE_PARENT_DSTATE;
extern uint16_t _TRACE_RESETTABLE_PHASE_ENTER_BEGIN_DSTATE;
extern uint16_t _TRACE_RESETTABLE_PHASE_ENTER_EXEC_DSTATE;
extern uint16_t _TRACE_RESETTABLE_PHASE_ENTER_END_DSTATE;
extern uint16_t _TRACE_RESETTABLE_PHASE_HOLD_BEGIN_DSTATE;
extern uint16_t _TRACE_RESETTABLE_PHASE_HOLD_EXEC_DSTATE;
extern uint16_t _TRACE_RESETTABLE_PHASE_HOLD_END_DSTATE;
extern uint16_t _TRACE_RESETTABLE_PHASE_EXIT_BEGIN_DSTATE;
extern uint16_t _TRACE_RESETTABLE_PHASE_EXIT_EXEC_DSTATE;
extern uint16_t _TRACE_RESETTABLE_PHASE_EXIT_END_DSTATE;
extern uint16_t _TRACE_RESETTABLE_TRANSITIONAL_FUNCTION_DSTATE;
extern uint16_t _TRACE_CLOCK_SET_SOURCE_DSTATE;
extern uint16_t _TRACE_CLOCK_DISCONNECT_DSTATE;
extern uint16_t _TRACE_CLOCK_SET_DSTATE;
extern uint16_t _TRACE_CLOCK_PROPAGATE_DSTATE;
extern uint16_t _TRACE_CLOCK_UPDATE_DSTATE;
extern uint16_t _TRACE_CLOCK_SET_MUL_DIV_DSTATE;
extern uint16_t _TRACE_CPU_RESET_DSTATE;
extern uint16_t _TRACE_REMOTE_PORT_MEMORY_MASTER_TX_BUSACCESS_DSTATE;
extern uint16_t _TRACE_REMOTE_PORT_MEMORY_MASTER_RX_BUSACCESS_DSTATE;
extern uint16_t _TRACE_REMOTE_PORT_MEMORY_SLAVE_TX_BUSACCESS_DSTATE;
extern uint16_t _TRACE_REMOTE_PORT_MEMORY_SLAVE_RX_BUSACCESS_DSTATE;
extern uint16_t _TRACE_REMOTE_PORT_GPIO_TX_INTERRUPT_DSTATE;
extern uint16_t _TRACE_REMOTE_PORT_GPIO_RX_INTERRUPT_DSTATE;
extern uint16_t _TRACE_REMOTE_PORT_STREAM_TX_BUSACCESS_DSTATE;
extern uint16_t _TRACE_REMOTE_PORT_STREAM_RX_BUSACCESS_DSTATE;
#define TRACE_LOADER_WRITE_ROM_ENABLED 1
#define TRACE_QDEV_UPDATE_PARENT_BUS_ENABLED 1
#define TRACE_RESETTABLE_RESET_ENABLED 1
#define TRACE_RESETTABLE_RESET_ASSERT_BEGIN_ENABLED 1
#define TRACE_RESETTABLE_RESET_ASSERT_END_ENABLED 1
#define TRACE_RESETTABLE_RESET_RELEASE_BEGIN_ENABLED 1
#define TRACE_RESETTABLE_RESET_RELEASE_END_ENABLED 1
#define TRACE_RESETTABLE_CHANGE_PARENT_ENABLED 1
#define TRACE_RESETTABLE_PHASE_ENTER_BEGIN_ENABLED 1
#define TRACE_RESETTABLE_PHASE_ENTER_EXEC_ENABLED 1
#define TRACE_RESETTABLE_PHASE_ENTER_END_ENABLED 1
#define TRACE_RESETTABLE_PHASE_HOLD_BEGIN_ENABLED 1
#define TRACE_RESETTABLE_PHASE_HOLD_EXEC_ENABLED 1
#define TRACE_RESETTABLE_PHASE_HOLD_END_ENABLED 1
#define TRACE_RESETTABLE_PHASE_EXIT_BEGIN_ENABLED 1
#define TRACE_RESETTABLE_PHASE_EXIT_EXEC_ENABLED 1
#define TRACE_RESETTABLE_PHASE_EXIT_END_ENABLED 1
#define TRACE_RESETTABLE_TRANSITIONAL_FUNCTION_ENABLED 1
#define TRACE_CLOCK_SET_SOURCE_ENABLED 1
#define TRACE_CLOCK_DISCONNECT_ENABLED 1
#define TRACE_CLOCK_SET_ENABLED 1
#define TRACE_CLOCK_PROPAGATE_ENABLED 1
#define TRACE_CLOCK_UPDATE_ENABLED 1
#define TRACE_CLOCK_SET_MUL_DIV_ENABLED 1
#define TRACE_CPU_RESET_ENABLED 1
#define TRACE_REMOTE_PORT_MEMORY_MASTER_TX_BUSACCESS_ENABLED 1
#define TRACE_REMOTE_PORT_MEMORY_MASTER_RX_BUSACCESS_ENABLED 1
#define TRACE_REMOTE_PORT_MEMORY_SLAVE_TX_BUSACCESS_ENABLED 1
#define TRACE_REMOTE_PORT_MEMORY_SLAVE_RX_BUSACCESS_ENABLED 1
#define TRACE_REMOTE_PORT_GPIO_TX_INTERRUPT_ENABLED 1
#define TRACE_REMOTE_PORT_GPIO_RX_INTERRUPT_ENABLED 1
#define TRACE_REMOTE_PORT_STREAM_TX_BUSACCESS_ENABLED 1
#define TRACE_REMOTE_PORT_STREAM_RX_BUSACCESS_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_LOADER_WRITE_ROM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADER_WRITE_ROM) || \
    false)

static inline void _nocheck__trace_loader_write_rom(const char * name, uint64_t gpa, uint64_t size, bool isrom)
{
    if (trace_event_get_state(TRACE_LOADER_WRITE_ROM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 2 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:loader_write_rom " "%s: @0x%"PRIx64" size=0x%"PRIx64" ROM=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, gpa, size, isrom);
#line 127 "trace/trace-hw_core.h"
        } else {
#line 2 "../hw/core/trace-events"
            qemu_log("loader_write_rom " "%s: @0x%"PRIx64" size=0x%"PRIx64" ROM=%d" "\n", name, gpa, size, isrom);
#line 131 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_loader_write_rom(const char * name, uint64_t gpa, uint64_t size, bool isrom)
{
    if (true) {
        _nocheck__trace_loader_write_rom(name, gpa, size, isrom);
    }
}

#define TRACE_QDEV_UPDATE_PARENT_BUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QDEV_UPDATE_PARENT_BUS) || \
    false)

static inline void _nocheck__trace_qdev_update_parent_bus(void * obj, const char * objtype, void * oldp, const char * oldptype, void * newp, const char * newptype)
{
    if (trace_event_get_state(TRACE_QDEV_UPDATE_PARENT_BUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:qdev_update_parent_bus " "obj=%p(%s) old_parent=%p(%s) new_parent=%p(%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, oldp, oldptype, newp, newptype);
#line 158 "trace/trace-hw_core.h"
        } else {
#line 5 "../hw/core/trace-events"
            qemu_log("qdev_update_parent_bus " "obj=%p(%s) old_parent=%p(%s) new_parent=%p(%s)" "\n", obj, objtype, oldp, oldptype, newp, newptype);
#line 162 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_qdev_update_parent_bus(void * obj, const char * objtype, void * oldp, const char * oldptype, void * newp, const char * newptype)
{
    if (true) {
        _nocheck__trace_qdev_update_parent_bus(obj, objtype, oldp, oldptype, newp, newptype);
    }
}

#define TRACE_RESETTABLE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_RESET) || \
    false)

static inline void _nocheck__trace_resettable_reset(void * obj, int cold)
{
    if (trace_event_get_state(TRACE_RESETTABLE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_reset " "obj=%p cold=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, cold);
#line 189 "trace/trace-hw_core.h"
        } else {
#line 8 "../hw/core/trace-events"
            qemu_log("resettable_reset " "obj=%p cold=%d" "\n", obj, cold);
#line 193 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_reset(void * obj, int cold)
{
    if (true) {
        _nocheck__trace_resettable_reset(obj, cold);
    }
}

#define TRACE_RESETTABLE_RESET_ASSERT_BEGIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_RESET_ASSERT_BEGIN) || \
    false)

static inline void _nocheck__trace_resettable_reset_assert_begin(void * obj, int cold)
{
    if (trace_event_get_state(TRACE_RESETTABLE_RESET_ASSERT_BEGIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_reset_assert_begin " "obj=%p cold=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, cold);
#line 220 "trace/trace-hw_core.h"
        } else {
#line 9 "../hw/core/trace-events"
            qemu_log("resettable_reset_assert_begin " "obj=%p cold=%d" "\n", obj, cold);
#line 224 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_reset_assert_begin(void * obj, int cold)
{
    if (true) {
        _nocheck__trace_resettable_reset_assert_begin(obj, cold);
    }
}

#define TRACE_RESETTABLE_RESET_ASSERT_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_RESET_ASSERT_END) || \
    false)

static inline void _nocheck__trace_resettable_reset_assert_end(void * obj)
{
    if (trace_event_get_state(TRACE_RESETTABLE_RESET_ASSERT_END) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_reset_assert_end " "obj=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj);
#line 251 "trace/trace-hw_core.h"
        } else {
#line 10 "../hw/core/trace-events"
            qemu_log("resettable_reset_assert_end " "obj=%p" "\n", obj);
#line 255 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_reset_assert_end(void * obj)
{
    if (true) {
        _nocheck__trace_resettable_reset_assert_end(obj);
    }
}

#define TRACE_RESETTABLE_RESET_RELEASE_BEGIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_RESET_RELEASE_BEGIN) || \
    false)

static inline void _nocheck__trace_resettable_reset_release_begin(void * obj, int cold)
{
    if (trace_event_get_state(TRACE_RESETTABLE_RESET_RELEASE_BEGIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_reset_release_begin " "obj=%p cold=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, cold);
#line 282 "trace/trace-hw_core.h"
        } else {
#line 11 "../hw/core/trace-events"
            qemu_log("resettable_reset_release_begin " "obj=%p cold=%d" "\n", obj, cold);
#line 286 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_reset_release_begin(void * obj, int cold)
{
    if (true) {
        _nocheck__trace_resettable_reset_release_begin(obj, cold);
    }
}

#define TRACE_RESETTABLE_RESET_RELEASE_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_RESET_RELEASE_END) || \
    false)

static inline void _nocheck__trace_resettable_reset_release_end(void * obj)
{
    if (trace_event_get_state(TRACE_RESETTABLE_RESET_RELEASE_END) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_reset_release_end " "obj=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj);
#line 313 "trace/trace-hw_core.h"
        } else {
#line 12 "../hw/core/trace-events"
            qemu_log("resettable_reset_release_end " "obj=%p" "\n", obj);
#line 317 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_reset_release_end(void * obj)
{
    if (true) {
        _nocheck__trace_resettable_reset_release_end(obj);
    }
}

#define TRACE_RESETTABLE_CHANGE_PARENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_CHANGE_PARENT) || \
    false)

static inline void _nocheck__trace_resettable_change_parent(void * obj, void * o, unsigned oc, void * n, unsigned nc)
{
    if (trace_event_get_state(TRACE_RESETTABLE_CHANGE_PARENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_change_parent " "obj=%p from=%p(%d) to=%p(%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, o, oc, n, nc);
#line 344 "trace/trace-hw_core.h"
        } else {
#line 13 "../hw/core/trace-events"
            qemu_log("resettable_change_parent " "obj=%p from=%p(%d) to=%p(%d)" "\n", obj, o, oc, n, nc);
#line 348 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_change_parent(void * obj, void * o, unsigned oc, void * n, unsigned nc)
{
    if (true) {
        _nocheck__trace_resettable_change_parent(obj, o, oc, n, nc);
    }
}

#define TRACE_RESETTABLE_PHASE_ENTER_BEGIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_PHASE_ENTER_BEGIN) || \
    false)

static inline void _nocheck__trace_resettable_phase_enter_begin(void * obj, const char * objtype, unsigned count, int type)
{
    if (trace_event_get_state(TRACE_RESETTABLE_PHASE_ENTER_BEGIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_phase_enter_begin " "obj=%p(%s) count=%d type=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, count, type);
#line 375 "trace/trace-hw_core.h"
        } else {
#line 14 "../hw/core/trace-events"
            qemu_log("resettable_phase_enter_begin " "obj=%p(%s) count=%d type=%d" "\n", obj, objtype, count, type);
#line 379 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_phase_enter_begin(void * obj, const char * objtype, unsigned count, int type)
{
    if (true) {
        _nocheck__trace_resettable_phase_enter_begin(obj, objtype, count, type);
    }
}

#define TRACE_RESETTABLE_PHASE_ENTER_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_PHASE_ENTER_EXEC) || \
    false)

static inline void _nocheck__trace_resettable_phase_enter_exec(void * obj, const char * objtype, int type, int has_method)
{
    if (trace_event_get_state(TRACE_RESETTABLE_PHASE_ENTER_EXEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_phase_enter_exec " "obj=%p(%s) type=%d method=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, type, has_method);
#line 406 "trace/trace-hw_core.h"
        } else {
#line 15 "../hw/core/trace-events"
            qemu_log("resettable_phase_enter_exec " "obj=%p(%s) type=%d method=%d" "\n", obj, objtype, type, has_method);
#line 410 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_phase_enter_exec(void * obj, const char * objtype, int type, int has_method)
{
    if (true) {
        _nocheck__trace_resettable_phase_enter_exec(obj, objtype, type, has_method);
    }
}

#define TRACE_RESETTABLE_PHASE_ENTER_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_PHASE_ENTER_END) || \
    false)

static inline void _nocheck__trace_resettable_phase_enter_end(void * obj, const char * objtype, unsigned count)
{
    if (trace_event_get_state(TRACE_RESETTABLE_PHASE_ENTER_END) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_phase_enter_end " "obj=%p(%s) count=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, count);
#line 437 "trace/trace-hw_core.h"
        } else {
#line 16 "../hw/core/trace-events"
            qemu_log("resettable_phase_enter_end " "obj=%p(%s) count=%d" "\n", obj, objtype, count);
#line 441 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_phase_enter_end(void * obj, const char * objtype, unsigned count)
{
    if (true) {
        _nocheck__trace_resettable_phase_enter_end(obj, objtype, count);
    }
}

#define TRACE_RESETTABLE_PHASE_HOLD_BEGIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_PHASE_HOLD_BEGIN) || \
    false)

static inline void _nocheck__trace_resettable_phase_hold_begin(void * obj, const char * objtype, unsigned count, int type)
{
    if (trace_event_get_state(TRACE_RESETTABLE_PHASE_HOLD_BEGIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_phase_hold_begin " "obj=%p(%s) count=%d type=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, count, type);
#line 468 "trace/trace-hw_core.h"
        } else {
#line 17 "../hw/core/trace-events"
            qemu_log("resettable_phase_hold_begin " "obj=%p(%s) count=%d type=%d" "\n", obj, objtype, count, type);
#line 472 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_phase_hold_begin(void * obj, const char * objtype, unsigned count, int type)
{
    if (true) {
        _nocheck__trace_resettable_phase_hold_begin(obj, objtype, count, type);
    }
}

#define TRACE_RESETTABLE_PHASE_HOLD_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_PHASE_HOLD_EXEC) || \
    false)

static inline void _nocheck__trace_resettable_phase_hold_exec(void * obj, const char * objtype, int has_method)
{
    if (trace_event_get_state(TRACE_RESETTABLE_PHASE_HOLD_EXEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_phase_hold_exec " "obj=%p(%s) method=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, has_method);
#line 499 "trace/trace-hw_core.h"
        } else {
#line 18 "../hw/core/trace-events"
            qemu_log("resettable_phase_hold_exec " "obj=%p(%s) method=%d" "\n", obj, objtype, has_method);
#line 503 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_phase_hold_exec(void * obj, const char * objtype, int has_method)
{
    if (true) {
        _nocheck__trace_resettable_phase_hold_exec(obj, objtype, has_method);
    }
}

#define TRACE_RESETTABLE_PHASE_HOLD_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_PHASE_HOLD_END) || \
    false)

static inline void _nocheck__trace_resettable_phase_hold_end(void * obj, const char * objtype, unsigned count)
{
    if (trace_event_get_state(TRACE_RESETTABLE_PHASE_HOLD_END) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_phase_hold_end " "obj=%p(%s) count=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, count);
#line 530 "trace/trace-hw_core.h"
        } else {
#line 19 "../hw/core/trace-events"
            qemu_log("resettable_phase_hold_end " "obj=%p(%s) count=%d" "\n", obj, objtype, count);
#line 534 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_phase_hold_end(void * obj, const char * objtype, unsigned count)
{
    if (true) {
        _nocheck__trace_resettable_phase_hold_end(obj, objtype, count);
    }
}

#define TRACE_RESETTABLE_PHASE_EXIT_BEGIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_PHASE_EXIT_BEGIN) || \
    false)

static inline void _nocheck__trace_resettable_phase_exit_begin(void * obj, const char * objtype, unsigned count, int type)
{
    if (trace_event_get_state(TRACE_RESETTABLE_PHASE_EXIT_BEGIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_phase_exit_begin " "obj=%p(%s) count=%d type=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, count, type);
#line 561 "trace/trace-hw_core.h"
        } else {
#line 20 "../hw/core/trace-events"
            qemu_log("resettable_phase_exit_begin " "obj=%p(%s) count=%d type=%d" "\n", obj, objtype, count, type);
#line 565 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_phase_exit_begin(void * obj, const char * objtype, unsigned count, int type)
{
    if (true) {
        _nocheck__trace_resettable_phase_exit_begin(obj, objtype, count, type);
    }
}

#define TRACE_RESETTABLE_PHASE_EXIT_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_PHASE_EXIT_EXEC) || \
    false)

static inline void _nocheck__trace_resettable_phase_exit_exec(void * obj, const char * objtype, int has_method)
{
    if (trace_event_get_state(TRACE_RESETTABLE_PHASE_EXIT_EXEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_phase_exit_exec " "obj=%p(%s) method=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, has_method);
#line 592 "trace/trace-hw_core.h"
        } else {
#line 21 "../hw/core/trace-events"
            qemu_log("resettable_phase_exit_exec " "obj=%p(%s) method=%d" "\n", obj, objtype, has_method);
#line 596 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_phase_exit_exec(void * obj, const char * objtype, int has_method)
{
    if (true) {
        _nocheck__trace_resettable_phase_exit_exec(obj, objtype, has_method);
    }
}

#define TRACE_RESETTABLE_PHASE_EXIT_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_PHASE_EXIT_END) || \
    false)

static inline void _nocheck__trace_resettable_phase_exit_end(void * obj, const char * objtype, unsigned count)
{
    if (trace_event_get_state(TRACE_RESETTABLE_PHASE_EXIT_END) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_phase_exit_end " "obj=%p(%s) count=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype, count);
#line 623 "trace/trace-hw_core.h"
        } else {
#line 22 "../hw/core/trace-events"
            qemu_log("resettable_phase_exit_end " "obj=%p(%s) count=%d" "\n", obj, objtype, count);
#line 627 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_phase_exit_end(void * obj, const char * objtype, unsigned count)
{
    if (true) {
        _nocheck__trace_resettable_phase_exit_end(obj, objtype, count);
    }
}

#define TRACE_RESETTABLE_TRANSITIONAL_FUNCTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RESETTABLE_TRANSITIONAL_FUNCTION) || \
    false)

static inline void _nocheck__trace_resettable_transitional_function(void * obj, const char * objtype)
{
    if (trace_event_get_state(TRACE_RESETTABLE_TRANSITIONAL_FUNCTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:resettable_transitional_function " "obj=%p(%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , obj, objtype);
#line 654 "trace/trace-hw_core.h"
        } else {
#line 23 "../hw/core/trace-events"
            qemu_log("resettable_transitional_function " "obj=%p(%s)" "\n", obj, objtype);
#line 658 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_resettable_transitional_function(void * obj, const char * objtype)
{
    if (true) {
        _nocheck__trace_resettable_transitional_function(obj, objtype);
    }
}

#define TRACE_CLOCK_SET_SOURCE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CLOCK_SET_SOURCE) || \
    false)

static inline void _nocheck__trace_clock_set_source(const char * clk, const char * src)
{
    if (trace_event_get_state(TRACE_CLOCK_SET_SOURCE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:clock_set_source " "'%s', src='%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , clk, src);
#line 685 "trace/trace-hw_core.h"
        } else {
#line 26 "../hw/core/trace-events"
            qemu_log("clock_set_source " "'%s', src='%s'" "\n", clk, src);
#line 689 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_clock_set_source(const char * clk, const char * src)
{
    if (true) {
        _nocheck__trace_clock_set_source(clk, src);
    }
}

#define TRACE_CLOCK_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CLOCK_DISCONNECT) || \
    false)

static inline void _nocheck__trace_clock_disconnect(const char * clk)
{
    if (trace_event_get_state(TRACE_CLOCK_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:clock_disconnect " "'%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , clk);
#line 716 "trace/trace-hw_core.h"
        } else {
#line 27 "../hw/core/trace-events"
            qemu_log("clock_disconnect " "'%s'" "\n", clk);
#line 720 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_clock_disconnect(const char * clk)
{
    if (true) {
        _nocheck__trace_clock_disconnect(clk);
    }
}

#define TRACE_CLOCK_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CLOCK_SET) || \
    false)

static inline void _nocheck__trace_clock_set(const char * clk, uint64_t old, uint64_t new)
{
    if (trace_event_get_state(TRACE_CLOCK_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:clock_set " "'%s', %"PRIu64"Hz->%"PRIu64"Hz" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , clk, old, new);
#line 747 "trace/trace-hw_core.h"
        } else {
#line 28 "../hw/core/trace-events"
            qemu_log("clock_set " "'%s', %"PRIu64"Hz->%"PRIu64"Hz" "\n", clk, old, new);
#line 751 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_clock_set(const char * clk, uint64_t old, uint64_t new)
{
    if (true) {
        _nocheck__trace_clock_set(clk, old, new);
    }
}

#define TRACE_CLOCK_PROPAGATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CLOCK_PROPAGATE) || \
    false)

static inline void _nocheck__trace_clock_propagate(const char * clk)
{
    if (trace_event_get_state(TRACE_CLOCK_PROPAGATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:clock_propagate " "'%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , clk);
#line 778 "trace/trace-hw_core.h"
        } else {
#line 29 "../hw/core/trace-events"
            qemu_log("clock_propagate " "'%s'" "\n", clk);
#line 782 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_clock_propagate(const char * clk)
{
    if (true) {
        _nocheck__trace_clock_propagate(clk);
    }
}

#define TRACE_CLOCK_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CLOCK_UPDATE) || \
    false)

static inline void _nocheck__trace_clock_update(const char * clk, const char * src, uint64_t hz, int cb)
{
    if (trace_event_get_state(TRACE_CLOCK_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:clock_update " "'%s', src='%s', val=%"PRIu64"Hz cb=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , clk, src, hz, cb);
#line 809 "trace/trace-hw_core.h"
        } else {
#line 30 "../hw/core/trace-events"
            qemu_log("clock_update " "'%s', src='%s', val=%"PRIu64"Hz cb=%d" "\n", clk, src, hz, cb);
#line 813 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_clock_update(const char * clk, const char * src, uint64_t hz, int cb)
{
    if (true) {
        _nocheck__trace_clock_update(clk, src, hz, cb);
    }
}

#define TRACE_CLOCK_SET_MUL_DIV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CLOCK_SET_MUL_DIV) || \
    false)

static inline void _nocheck__trace_clock_set_mul_div(const char * clk, uint32_t oldmul, uint32_t mul, uint32_t olddiv, uint32_t div)
{
    if (trace_event_get_state(TRACE_CLOCK_SET_MUL_DIV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:clock_set_mul_div " "'%s', mul: %u -> %u, div: %u -> %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , clk, oldmul, mul, olddiv, div);
#line 840 "trace/trace-hw_core.h"
        } else {
#line 31 "../hw/core/trace-events"
            qemu_log("clock_set_mul_div " "'%s', mul: %u -> %u, div: %u -> %u" "\n", clk, oldmul, mul, olddiv, div);
#line 844 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_clock_set_mul_div(const char * clk, uint32_t oldmul, uint32_t mul, uint32_t olddiv, uint32_t div)
{
    if (true) {
        _nocheck__trace_clock_set_mul_div(clk, oldmul, mul, olddiv, div);
    }
}

#define TRACE_CPU_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_RESET) || \
    false)

static inline void _nocheck__trace_cpu_reset(int cpu_index)
{
    if (trace_event_get_state(TRACE_CPU_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_reset " "%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index);
#line 871 "trace/trace-hw_core.h"
        } else {
#line 34 "../hw/core/trace-events"
            qemu_log("cpu_reset " "%d" "\n", cpu_index);
#line 875 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_cpu_reset(int cpu_index)
{
    if (true) {
        _nocheck__trace_cpu_reset(cpu_index);
    }
}

#define TRACE_REMOTE_PORT_MEMORY_MASTER_TX_BUSACCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_REMOTE_PORT_MEMORY_MASTER_TX_BUSACCESS) || \
    false)

static inline void _nocheck__trace_remote_port_memory_master_tx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (trace_event_get_state(TRACE_REMOTE_PORT_MEMORY_MASTER_TX_BUSACCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:remote_port_memory_master_tx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, id, flags, dev, addr, len, attr);
#line 902 "trace/trace-hw_core.h"
        } else {
#line 37 "../hw/core/trace-events"
            qemu_log("remote_port_memory_master_tx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n", cmd, id, flags, dev, addr, len, attr);
#line 906 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_remote_port_memory_master_tx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (true) {
        _nocheck__trace_remote_port_memory_master_tx_busaccess(cmd, id, flags, dev, addr, len, attr);
    }
}

#define TRACE_REMOTE_PORT_MEMORY_MASTER_RX_BUSACCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_REMOTE_PORT_MEMORY_MASTER_RX_BUSACCESS) || \
    false)

static inline void _nocheck__trace_remote_port_memory_master_rx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (trace_event_get_state(TRACE_REMOTE_PORT_MEMORY_MASTER_RX_BUSACCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:remote_port_memory_master_rx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, id, flags, dev, addr, len, attr);
#line 933 "trace/trace-hw_core.h"
        } else {
#line 38 "../hw/core/trace-events"
            qemu_log("remote_port_memory_master_rx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n", cmd, id, flags, dev, addr, len, attr);
#line 937 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_remote_port_memory_master_rx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (true) {
        _nocheck__trace_remote_port_memory_master_rx_busaccess(cmd, id, flags, dev, addr, len, attr);
    }
}

#define TRACE_REMOTE_PORT_MEMORY_SLAVE_TX_BUSACCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_REMOTE_PORT_MEMORY_SLAVE_TX_BUSACCESS) || \
    false)

static inline void _nocheck__trace_remote_port_memory_slave_tx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (trace_event_get_state(TRACE_REMOTE_PORT_MEMORY_SLAVE_TX_BUSACCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:remote_port_memory_slave_tx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, id, flags, dev, addr, len, attr);
#line 964 "trace/trace-hw_core.h"
        } else {
#line 41 "../hw/core/trace-events"
            qemu_log("remote_port_memory_slave_tx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n", cmd, id, flags, dev, addr, len, attr);
#line 968 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_remote_port_memory_slave_tx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (true) {
        _nocheck__trace_remote_port_memory_slave_tx_busaccess(cmd, id, flags, dev, addr, len, attr);
    }
}

#define TRACE_REMOTE_PORT_MEMORY_SLAVE_RX_BUSACCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_REMOTE_PORT_MEMORY_SLAVE_RX_BUSACCESS) || \
    false)

static inline void _nocheck__trace_remote_port_memory_slave_rx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (trace_event_get_state(TRACE_REMOTE_PORT_MEMORY_SLAVE_RX_BUSACCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:remote_port_memory_slave_rx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, id, flags, dev, addr, len, attr);
#line 995 "trace/trace-hw_core.h"
        } else {
#line 42 "../hw/core/trace-events"
            qemu_log("remote_port_memory_slave_rx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n", cmd, id, flags, dev, addr, len, attr);
#line 999 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_remote_port_memory_slave_rx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (true) {
        _nocheck__trace_remote_port_memory_slave_rx_busaccess(cmd, id, flags, dev, addr, len, attr);
    }
}

#define TRACE_REMOTE_PORT_GPIO_TX_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_REMOTE_PORT_GPIO_TX_INTERRUPT) || \
    false)

static inline void _nocheck__trace_remote_port_gpio_tx_interrupt(uint32_t id, uint32_t flags, uint32_t dev, uint64_t vector, uint32_t irq, uint32_t val)
{
    if (trace_event_get_state(TRACE_REMOTE_PORT_GPIO_TX_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:remote_port_gpio_tx_interrupt " "id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", vector=0x%"PRIx64", irq=0x%"PRIx32", level=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, flags, dev, vector, irq, val);
#line 1026 "trace/trace-hw_core.h"
        } else {
#line 45 "../hw/core/trace-events"
            qemu_log("remote_port_gpio_tx_interrupt " "id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", vector=0x%"PRIx64", irq=0x%"PRIx32", level=0x%"PRIx32 "\n", id, flags, dev, vector, irq, val);
#line 1030 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_remote_port_gpio_tx_interrupt(uint32_t id, uint32_t flags, uint32_t dev, uint64_t vector, uint32_t irq, uint32_t val)
{
    if (true) {
        _nocheck__trace_remote_port_gpio_tx_interrupt(id, flags, dev, vector, irq, val);
    }
}

#define TRACE_REMOTE_PORT_GPIO_RX_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_REMOTE_PORT_GPIO_RX_INTERRUPT) || \
    false)

static inline void _nocheck__trace_remote_port_gpio_rx_interrupt(uint32_t id, uint32_t flags, uint32_t dev, uint64_t vector, uint32_t irq, uint32_t val)
{
    if (trace_event_get_state(TRACE_REMOTE_PORT_GPIO_RX_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:remote_port_gpio_rx_interrupt " "id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", vector=0x%"PRIx64", irq=0x%"PRIx32", level=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, flags, dev, vector, irq, val);
#line 1057 "trace/trace-hw_core.h"
        } else {
#line 46 "../hw/core/trace-events"
            qemu_log("remote_port_gpio_rx_interrupt " "id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", vector=0x%"PRIx64", irq=0x%"PRIx32", level=0x%"PRIx32 "\n", id, flags, dev, vector, irq, val);
#line 1061 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_remote_port_gpio_rx_interrupt(uint32_t id, uint32_t flags, uint32_t dev, uint64_t vector, uint32_t irq, uint32_t val)
{
    if (true) {
        _nocheck__trace_remote_port_gpio_rx_interrupt(id, flags, dev, vector, irq, val);
    }
}

#define TRACE_REMOTE_PORT_STREAM_TX_BUSACCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_REMOTE_PORT_STREAM_TX_BUSACCESS) || \
    false)

static inline void _nocheck__trace_remote_port_stream_tx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (trace_event_get_state(TRACE_REMOTE_PORT_STREAM_TX_BUSACCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:remote_port_stream_tx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, id, flags, dev, addr, len, attr);
#line 1088 "trace/trace-hw_core.h"
        } else {
#line 49 "../hw/core/trace-events"
            qemu_log("remote_port_stream_tx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n", cmd, id, flags, dev, addr, len, attr);
#line 1092 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_remote_port_stream_tx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (true) {
        _nocheck__trace_remote_port_stream_tx_busaccess(cmd, id, flags, dev, addr, len, attr);
    }
}

#define TRACE_REMOTE_PORT_STREAM_RX_BUSACCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_REMOTE_PORT_STREAM_RX_BUSACCESS) || \
    false)

static inline void _nocheck__trace_remote_port_stream_rx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (trace_event_get_state(TRACE_REMOTE_PORT_STREAM_RX_BUSACCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/core/trace-events"
            qemu_log("%d@%zu.%06zu:remote_port_stream_rx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, id, flags, dev, addr, len, attr);
#line 1119 "trace/trace-hw_core.h"
        } else {
#line 50 "../hw/core/trace-events"
            qemu_log("remote_port_stream_rx_busaccess " "cmd=%s, id=0x%"PRIx32", flags=0x%"PRIx32", dev=0x%"PRIx32", addr=0x%"PRIx64", len=0x%"PRIx32", attr=0x%"PRIx64 "\n", cmd, id, flags, dev, addr, len, attr);
#line 1123 "trace/trace-hw_core.h"
        }
    }
}

static inline void trace_remote_port_stream_rx_busaccess(const char * cmd, uint32_t id, uint32_t flags, uint32_t dev, uint64_t addr, uint32_t len, uint64_t attr)
{
    if (true) {
        _nocheck__trace_remote_port_stream_rx_busaccess(cmd, id, flags, dev, addr, len, attr);
    }
}
#endif /* TRACE_HW_CORE_GENERATED_TRACERS_H */
